# Odnix Architecture & Protocol Design Specification
## "The Telegram Model"

This document outlines the logical architecture for the **Odnix** project. It is designed to mirror the security, speed, and synchronization philosophy of **Telegram** and its **MTProto** protocol, adapted for a modern Web/Django environment.

---

## 1. High-Level System Architecture

Odnix operates on a **Client-Server-Client** model for reliable cloud storage/sync, combined with a **Client-Client (P2P)** encrypted tunnel for calls and secret chats.

### 1.1 The "Data Center" Concept
Unlike standard web apps that are "Requests" based, Odnix is "Session" based.
*   **The Session:** When a user opens Odnix, they do not just "log in". They create a **Long-Lived Session** identified by an `Auth_Key_ID`.
*   **Virtual Connection:** Even if the WebSocket disconnects (network loss), the *Session* remains alive on the server. When the socket reconnects, it resumes the session state rather than re-authenticating.

### 1.2 The "Updates" Dispatcher
To guarantee specific delivery and order (like Telegram), Odnix uses an **Updates Engine** instead of simple pub/sub.
*   **Logic:** Every event (New Message, Read Status, Typing) is an "Update".
*   **State Tracking (`pts` & `seq`):**
    *   Every user has a persistent state cursor called `pts` (Persistent Time Stamp) stored in the DB.
    *   When the client connects, it says: "I am at `pts: 105`".
    *   The server replies: "The current state is `pts: 110`. Here are updates 106, 107, 108, 109, 110."
    *   **Benefit:** This guarantees no lost messages and perfect sync across mobile/desktop.

---

## 2. OdnixProto (The Protocol)

OdnixProto is the transport layer. It replaces standard JSON/REST logic. It operates inside the WebSocket.

### 2.1 The Container
Every packet sent over rotation is wrapped in a secure container.
**Structure (Logical):**
```text
[ Auth_Key_ID (64-bit) ]  -> Identifies the Security Session (not the user ID)
[ Message_Key (128-bit)]  -> SHA-256 hash of the payload (Integrity Check)
[ AES_Encrypted_Data   ]  -> The payload encrypted with AES-256-IGE
```

### 2.2 The Payload
Inside the `AES_Encrypted_Data`, the actual content exists:
```text
[ Session_ID (64-bit) ]   -> Random ID generated by client on startup
[ Message_ID (64-bit) ]   -> Time-dependent unique ID (prevents Replay Attacks)
[ Seq_No     (32-bit) ]   -> Strict sequence for ordering
[ Length     (32-bit) ]   -> Byte length of object
[ Object_Data         ]   -> The actual JSON/Data
```

### 2.3 The Handshake (Logic)
Before any data flows, a "Diffie-Hellman" Key Exchange must occur.
1.  **C->S (Req_PQ):** Client sends a random nonce.
2.  **S->C (Res_PQ):** Server sends a "Puzzle" (Prime numbers) + Server Nonce.
3.  **C->S (Req_DH):** Client solves puzzle, generates a temporary Private Key (`a`), sends Public Key (`g^a`).
4.  **S->C (Res_DH):** Server generates temporary Private Key (`b`), computes Shared Secret (`g^ab`), sends Public Key (`g^b`).
5.  **Result:** Both sides now have `Auth_Key` (the shared secret). This key **never** leaves the device.

---

## 3. Communication Modules

### 3.1 Cloud Chats (Default)
This is the standard messaging mode.
*   **Encryption:** Client $\leftrightarrow$ Server (using OdnixProto).
*   **Storage:** Server stores decryptable history (to allow syncing).
*   **Flow:**
    1.  Client wraps message in OdnixProto.
    2.  Server receives, decrypts using Session Key.
    3.  Server stores in DB (assigns `pts`).
    4.  Server pushes "UpdateNewMessage" to Recipient's "Updates Queue".
    5.  Recipient (when online) receives the encrypted update.

### 3.2 Secret Chats (End-to-End Encrypted)
This mode ensures the server **cannot** read data.
*   **Layering:** An encrypted packet *inside* an encrypted packet.
    1.  **Outer Layer:** Standard OdnixProto (so server knows who to route to).
    2.  **Inner Layer:** E2E Layer (Payload encrypted with a key known ONLY to Alice and Bob).
*   **Key Viz:** The "Visual Fingerprint" (4 Emojis) is generated from the hash of this Inner Key.

### 3.3 Audio/Video Calls
Calls use a hybrid approach (Signaling + P2P).
*   **Phase 1: The Setup (Signaling)**
    *   Calls are treated logically as an "Ephemeral Secret Chat".
    *   Alice and Bob perform a DH exchange via the server to create a specific `Call_Key`.
    *   All Signaling (IPs, Ports, ICE Candidates) is encrypted with this `Call_Key`.
    *   *Result:* Server routes packets but sees only garbage. It does not know the IP addresses if P2P is established.
*   **Phase 2: The Stream (Media)**
    *   **verification:** Users verify the 4 Emojis (derived from `Call_Key`).
    *   **Transport:** WebRTC (UDP). Use the `Call_Key` to bootstrap the SRTP encryption.

---

## 4. Reliability & Optimization Logic

### 4.1 "Smart" Connection State
*   **Logic:** The client maintains a rigorous connection state machine.
    *   `State: Connecting` -> Handshake
    *   `State: Updating` -> Fetching missed `pts` gaps.
    *   `State: Ready` -> Real-time Pushing.
*   **Keep-Alive:** If no data flows for X seconds, send specific "Ping" packets (encrypted) to keep the NAT tunnel open.

### 4.2 Traffic Obfuscation
*   To prevent firewalls from blocking "Odnix", the OdnixProto packets should look like random noise.
*   **Padding:** Add random bytes to the end of packets so strict size analysis fails.
*   **Uniformity:** A "Typeing Status" packet and a "Call Offer" packet look mathematically identical (random noise) from the outside due to AES-IGE.

### 4.3 Media Handling
*   **Upload:** Media is uploaded to a separate "File Server" endpoint. It returns a `file_reference`.
*   **Message:** The chat message contains only the `file_reference` and a "Thumbnail" (blurred, low-res base64) for immediate display.
*   **Download:** The client requests the file using the `file_reference`.

---

## Summary of Logic Flow
1.  **Open App** -> WebSocket Connect.
2.  **Handshake** -> Establish `Auth_Key` (Diffie-Hellman).
3.  **Sync** -> Send `current_pts`. Server sends `updates` (missing messages).
4.  **Idle** -> Maintain encrypted Ping/Pong.
5.  **Send Message** -> Encrypt (AES-IGE) -> Wrap (Auth_ID) -> Send.
6.  **Call** -> Create "Secret" Session -> Exchange Keys -> Encrypt Signaling -> P2P Media.
