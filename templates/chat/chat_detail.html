{% extends 'chat/base.html' %}

{% block extra_head %}
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, interactive-widget=resizes-content">
{% endblock %}

{% block title %}
    {% if chat.chat_type == 'group' %}
        {{ chat.name }} - Odnix
    {% else %}
        Chat - Odnix
    {% endif %}
{% endblock %}

{% block content %}
<!-- FIXED: Hide debug messages that appear as raw text -->
<div style="display: none;">
    {{ messages }}
</div>

<div class="main-container-chat">
    <!-- Enhanced Sidebar - Hidden on Mobile -->
    <div class="sidebar-enhanced-chat" id="sidebar">
        <div class="sidebar-header">
            <h1 class="logo">Odnix</h1>
            <div class="user-info-compact">
                <div class="user-avatar-small">
                    <img src="{{ user.profile_picture_url }}" alt="{{ user.full_name }}" class="profile-avatar-small"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="avatar-fallback-small">{{ user.name.0 }}{{ user.lastname.0 }}</div>
                </div>
                <div class="user-details-small">
                    <div class="user-name-small">{{ user.full_name }}</div>
                    <div class="user-status-small">@{{ user.username }}</div>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <nav class="sidebar-nav-compact">
            <a href="{% url 'dashboard' %}" class="nav-item-compact">
                <i data-lucide="home" class="nav-icon"></i>
                <span class="nav-text">Dashboard</span>
            </a>
            <a href="{% url 'profile' %}" class="nav-item-compact">
                <i data-lucide="user" class="nav-icon"></i>
                <span class="nav-text">Profile</span>
            </a>
        </nav>

        <!-- Active Chats Section -->
        <div class="sidebar-section">
            <h3 class="sidebar-section-title">
                Active Chats
            </h3>
            <div class="sidebar-chat-list">
                {% for user_chat in user.chats.all|slice:":10" %}
                <a href="{% url 'chat_detail' user_chat.id %}" class="sidebar-chat-item {% if user_chat.id == chat.id %}active{% endif %}">
                    <div class="chat-avatar-small {% if user_chat.chat_type == 'group' %}group-avatar{% endif %}">
                        {% if user_chat.chat_type == 'group' %}
                            <i data-lucide="users" class="group-icon"></i>
                        {% else %}
                            {% for participant in user_chat.participants.all %}
                                {% if participant != user %}
                                    <img src="{{ participant.profile_picture_url }}" alt="{{ participant.full_name }}" class="profile-avatar-small"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                    <div class="avatar-fallback-small">{{ participant.name.0 }}{{ participant.lastname.0 }}</div>
                                {% endif %}
                            {% endfor %}
                        {% endif %}
                    </div>
                    <div class="chat-info-small">
                        <div class="chat-name-small">
                            {% if user_chat.chat_type == 'group' %}
                                {{ user_chat.name }}
                                {% if user_chat.admin == user %}
                                    <i data-lucide="crown" class="admin-badge"></i>
                                {% endif %}
                            {% else %}
                                {% for participant in user_chat.participants.all %}
                                    {% if participant != user %}
                                        {{ participant.full_name }}
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        </div>
                        <div class="chat-meta">
                            {% if user_chat.messages.last %}
                                {{ user_chat.updated_at|timesince }} ago
                            {% else %}
                                No messages
                            {% endif %}
                        </div>
                    </div>
                </a>
                {% endfor %}
            </div>
        </div>

        <!-- All Users Section -->
        <div class="sidebar-section">
            <h3 class="sidebar-section-title">Users</h3>
            <div class="sidebar-users-list">
                {% for other_user in chat.participants.all|slice:":5" %}
                    {% if other_user != user %}
                    <div class="sidebar-user-item">
                        <div class="user-avatar-tiny">
                            <img src="{{ other_user.profile_picture_url }}" alt="{{ other_user.full_name }}" class="profile-avatar-tiny"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="avatar-fallback-tiny">{{ other_user.name.0 }}{{ other_user.lastname.0 }}</div>
                        </div>
                        <div class="user-info-tiny">
                            <div class="user-name-tiny">
                                <a href="{% url 'user_profile' other_user.username %}" class="profile-link-small">
                                    {{ other_user.full_name }}
                                </a>
                            </div>
                        </div>
                    </div>
                    {% endif %}
                {% endfor %}
            </div>
        </div>
    </div>

    <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeMobileSidebar()"></div>

    <!-- Main Chat Area -->
    <div class="chat-content-area">
        <!-- Enhanced Chat Header with Mobile Back Button -->
        <div class="chat-header-enhanced">
            <!-- Mobile Back Button (left side) -->
            <div class="mobile-header-left">
                <button class="mobile-back-btn" onclick="goBack()">
                    <i data-lucide="arrow-left"></i>
                </button>
            </div>

            <div class="chat-title-section">
                <div class="chat-avatar-header">
                    {% if chat.chat_type == 'group' %}
                        <i data-lucide="users" class="group-header-icon"></i>
                    {% else %}
                        {% for participant in other_participants %}
                            <img src="{{ participant.profile_picture_url }}" alt="{{ participant.full_name }}" class="profile-avatar-header"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="avatar-fallback-header">{{ participant.name.0 }}{{ participant.lastname.0 }}</div>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="chat-info-header">
                    <h2>
                        {% if chat.chat_type == 'group' %}
                            {{ chat.name }}
                            {% if is_admin %}
                                <i data-lucide="crown" class="admin-badge-header"></i> Admin
                            {% endif %}
                        {% else %}
                            {% for participant in other_participants %}
                                {{ participant.full_name }}
                            {% endfor %}
                        {% endif %}
                    </h2>
                    <div class="chat-status-header">
                        {% if chat.chat_type == 'group' %}
                            <span class="member-count"><i data-lucide="user"></i> {{ chat.participant_count }} members</span>
                            {% if chat.invite_code %}
                                <button onclick="shareInviteLink()" class="btn-link"><i data-lucide="clipboard"></i> Share invite</button>
                            {% endif %}
                        {% else %}
                            {% for participant in other_participants %}
                                {% if participant.is_online %}
                                    <span class="status-online"><i data-lucide="circle" class="online-dot"></i> Online</span>
                                {% else %}
                                    <span class="status-offline"><i data-lucide="circle" class="offline-dot"></i> Last seen {{ participant.last_seen|timesince }} ago</span>
                                {% endif %}
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
            </div>

            <div class="chat-actions-header">
                {% if chat.chat_type == 'private' and other_participants %}
                    {% for participant in other_participants %}
                        <a href="{% url 'user_profile' participant.username %}" class="btn btn--secondary btn--small desktop-only">
                            <i data-lucide="user"></i> Profile
                        </a>
                    {% endfor %}
                {% endif %}

                {% if chat.chat_type == 'group' %}
                    <button onclick="openGroupSettings()" class="btn btn--secondary btn--small desktop-only">
                        <i data-lucide="settings"></i> Group Info
                    </button>
                {% endif %}

                {% if is_admin and join_requests %}
                    <button onclick="toggleJoinRequests()" class="btn btn--warning btn--small">
                        <i data-lucide="clock"></i> {{ join_requests.count }} Request{{ join_requests.count|pluralize }}
                    </button>
                {% endif %}
                
                <!-- Mobile Menu Button (right side) -->
                <button class="mobile-menu-btn" onclick="toggleMobileSidebar()">
                    <i data-lucide="menu"></i>
                </button>
            </div>
        </div>

        <!-- Join Requests Panel (for group admins) -->
        {% if is_admin and join_requests %}
        <div id="joinRequestsPanel" class="join-requests-panel" style="display: none;">
            <h3>Pending Join Requests</h3>
            {% for request in join_requests %}
            <div class="join-request-item-chat" data-request-id="{{ request.id }}">
                <div class="request-user-info">
                    <div class="requester-avatar-small">
                        <img src="{{ request.user.profile_picture_url }}" alt="{{ request.user.full_name }}" class="profile-avatar-small"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <div class="avatar-fallback-small">{{ request.user.name.0 }}{{ request.user.lastname.0 }}</div>
                    </div>
                    <div class="request-details-small">
                        <div class="requester-name-small">{{ request.user.full_name }}</div>
                        {% if request.message %}
                            <div class="request-message-small">"{{ request.message }}"</div>
                        {% endif %}
                        <div class="request-time-small">{{ request.requested_at|timesince }} ago</div>
                    </div>
                </div>
                <div class="request-actions-small">
                    <button onclick="manageJoinRequest({{ request.id }}, 'approve')" class="btn-mini btn--primary">
                        <i data-lucide="check"></i>
                    </button>
                    <button onclick="manageJoinRequest({{ request.id }}, 'reject')" class="btn-mini btn--danger">
                        <i data-lucide="x"></i>
                    </button>
                </div>
            </div>
            {% endfor %}
        </div>
        {% endif %}

        <!-- Pinned Messages Section -->
        <div id="pinnedMessagesSection" class="pinned-messages-section" style="display: none;">
            <div class="pinned-messages-header">
                <i data-lucide="pin"></i>
                <span>Pinned Messages</span>
            </div>
            <div id="pinnedMessagesList"></div>
        </div>

        <!-- Enhanced Messages Container -->
        <div class="messages-container-enhanced" id="messages-container">
            {% for message in messages %}
            <div class="message {% if message.sender == user %}message--own{% endif %} {% if message.message_type == 'system' %}message--system{% endif %} {% if message.is_pinned %}message--pinned{% endif %}" 
                 data-message-id="{{ message.id }}"
                 data-is-edited="{{ message.is_edited|yesno:'true,false' }}"
                 data-is-pinned="{{ message.is_pinned|yesno:'true,false' }}">
                
                {% if message.is_pinned %}
                <div class="pinned-indicator">
                    <i data-lucide="pin" class="pin-icon"></i> Pinned
                </div>
                {% endif %}
                
                <div class="message-bubble">
                    {% if message.reply_to %}
                    <div class="reply-indicator" onclick="scrollToMessage('{{ message.reply_to.id }}')" title="Click to view original message">
                        <div class="reply-content">
                            <strong>{{ message.reply_to.sender.full_name }}</strong>: {{ message.reply_to.content|truncatechars:50 }}
                        </div>
                    </div>
                    {% endif %}
                    
                    <!-- 3-dot Menu Button -->
<div class="message-menu-container">
    <button class="message-menu-btn" onclick="toggleMessageMenu(this)"><span></span></button>
    <div class="message-menu">
        <div class="menu-action" onclick="replyToMessage('{{ message.id }}'); closeAllMenus();" title="Reply">‚Ü©Ô∏è</div>
        <div class="menu-action" onclick="openReactionPicker('{{ message.id }}'); closeAllMenus();" title="React">‚ù§Ô∏è</div>
        <div class="menu-action star-btn" onclick="toggleStarMessage('{{ message.id }}'); closeAllMenus();" title="Star" data-message-id="{{ message.id }}">‚≠ê</div>
        {% if message.sender == user and message.can_be_edited %}
        <div class="menu-action" onclick="editMessage('{{ message.id }}'); closeAllMenus();" title="Edit">‚úèÔ∏è</div>
        {% endif %}
        {% if chat.chat_type == 'private' or chat.admin == user %}
        <div class="menu-action pin-action" onclick="togglePinMessage('{{ message.id }}'); closeAllMenus();" title="{% if message.is_pinned %}Unpin{% else %}Pin{% endif %}" data-pinned="{{ message.is_pinned|yesno:'true,false' }}">{% if message.is_pinned %}üìç{% else %}üìå{% endif %}</div>
        {% endif %}
        <div class="menu-action" onclick="showDeleteModal('{{ message.id }}', {{ message.sender.id }} === {{ user.id }}); closeAllMenus();" title="Delete">üóëÔ∏è</div>
    </div>
</div>

                    {% if message.message_type == 'system' %}
                        <i data-lucide="info" class="system-message-icon"></i>
                        {{ message.content }}
                    {% else %}
                        <!-- Show sender name only for other people's messages in group chats -->
                        {% if message.sender != user and chat.chat_type == 'group' %}
                            <div class="sender-name">{{ message.sender.full_name }}</div>
                        {% endif %}
                        
                        <!-- Message content with media support -->
                        <div class="message-content">
                            {% if message.one_time and message.consumed_at and message.sender != user %}
                                <!-- One-time message already viewed -->
                                <div class="one-time-viewed">
                                    <i data-lucide="eye" class="one-time-icon"></i>
                                    <span>One-time message viewed</span>
                                </div>
                            {% elif message.one_time and not message.consumed_at and message.sender != user %}
                                <!-- One-time message sealed card (for recipients only) -->
                                <div class="one-time-message" onclick="consumeOneTimeMessage({{ message.id }})">
                                    <i data-lucide="eye-off" class="one-time-icon"></i>
                                    <span class="one-time-text">Tap to view one-time message</span>
                                </div>
                            {% elif message.one_time and message.sender == user %}
                                <!-- Sender's own one-time message -->
                                {% if message.consumed_at %}
                                    <div class="one-time-opened">
                                        <i data-lucide="eye" class="one-time-icon"></i>
                                        <span>Opened</span>
                                    </div>
                                {% else %}
                                    <div class="one-time-pending">
                                        <i data-lucide="eye-off" class="one-time-icon"></i>
                                        <span>Not opened yet</span>
                                    </div>
                                {% endif %}
                            {% elif message.media_type == 'image' %}
                                <img src="{{ message.media_url }}" alt="Image" class="message-image" onclick="openMediaViewer('{{ message.media_url }}', 'image')">
                            {% elif message.media_type == 'video' %}
                                <video controls class="message-video">
                                    <source src="{{ message.media_url }}" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                            {% else %}
                                <div class="message-text">{{ message.content|linebreaks }}</div>
                            {% endif %}
                        </div>

                        <div class="message-time">
                            {{ message.timestamp|date:"H:i" }}
                            {% if message.is_edited %}
                            <span class="edited-indicator" title="Edited {{ message.edited_at|date:'M d, H:i' }}">
                                (edited)
                            </span>
                            {% endif %}
                            {% if message.sender == user %}
                            <span class="read-receipt" data-message-id="{{ message.id }}" title="Sent">
                                ‚úì
                            </span>
                            {% endif %}
                        </div>

                        <!-- Reactions display at bottom -->
                        <div class="message-reactions" id="reactions-{{ message.id }}">
                          {% for reaction in message.message_reactions.all %}
                            <span class="reaction" data-emoji="{{ reaction.emoji }}" onclick="window.chatApp.addReaction({{ message.id }}, '{{ reaction.emoji }}')">{{ reaction.emoji }}</span>
                          {% endfor %}
                        </div>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
        
        <!-- Typing Indicator - Fixed position above input -->
        <div id="typingIndicator" class="typing-indicator-fixed" style="display: none;">
            <div class="typing-bubble-content">
                <div class="typing-dots-animated">
                    <span></span><span></span><span></span>
                </div>
                <span id="typingText" class="typing-name"></span>
            </div>
        </div>

        <!-- Enhanced Message Input with Media Support -->
        <div class="message-input-container-enhanced">
            <!-- Media Preview Area -->
            <div id="mediaPreview" class="media-preview-area" style="display: none;">
                <div class="media-preview-content">
                    <img id="previewImage" style="display: none;" class="preview-media">
                    <video id="previewVideo" style="display: none;" class="preview-media" controls></video>
                </div>
                <button class="media-preview-close" onclick="closeMediaPreview()">√ó</button>
            </div>

            <form id="messageForm" enctype="multipart/form-data">
                {% csrf_token %}
                <input type="hidden" id="chatId" value="{{ chat.id }}">
                <input type="file" id="mediaInput" accept="image/*,video/*" style="display: none;" onchange="handleMediaSelect(event)">

                <!-- Reply Preview Box -->
                <div id="reply-preview" style="display: none; padding: 0.5rem; background: #e0e7ff; border-left: 3px solid #667eea; margin-bottom: 0.5rem; border-radius: 0.5rem;">
                    <span id="reply-text"></span>
                    <button type="button" onclick="cancelReply()" style="float: right; background: none; border: none; cursor: pointer; color: #667eea;">‚úï</button>
                </div>

                <div class="message-input-wrapper-enhanced">
                    <!-- Media and Emoji Buttons -->
                    <div class="input-actions-left">
                        <button type="button" class="action-btn media-btn" onclick="document.getElementById('mediaInput').click()" title="Send Image/Video">
                            <i data-lucide="image" class="action-icon"></i>
                        </button>
                        <button type="button" class="action-btn p2p-btn" onclick="openP2PFileShare()" title="P2P File Share (Unlimited)">
                            <i data-lucide="share" class="action-icon"></i>
                        </button>
                        <button type="button" id="oneTimeBtn" class="action-btn one-time-btn" onclick="toggleOneTime()" title="Send as one-time message">
                            <i data-lucide="eye-off" class="action-icon"></i>
                        </button>
                        <button type="button" class="action-btn emoji-btn" onclick="toggleEmojiPicker()" title="Add Emoji">
                            <i data-lucide="smile" class="action-icon"></i>
                        </button>
                    </div>

                    <!-- Text Input -->
                    <textarea id="messageInput" placeholder="Type a message..." rows="1" autocomplete="off" class="message-textarea-enhanced"></textarea>

                    <!-- Send Button -->
                    <button type="submit" class="btn btn--primary send-btn-enhanced" id="sendBtn">
                        <i data-lucide="send" class="send-icon send-icon-send"></i>
                        <i data-lucide="loader-2" class="send-icon send-icon-loading spinning" style="display: none;"></i>
                    </button>
                </div>

                <!-- Emoji Picker -->
                <div id="emojiPicker" class="emoji-picker" style="display: none;">
                    <div class="emoji-categories">
                        <button class="emoji-category active" onclick="showEmojiCategory('smileys')">üòä</button>
                        <button class="emoji-category" onclick="showEmojiCategory('people')">üë§</button>
                        <button class="emoji-category" onclick="showEmojiCategory('animals')">üêµ</button>
                        <button class="emoji-category" onclick="showEmojiCategory('food')">üçï</button>
                        <button class="emoji-category" onclick="showEmojiCategory('activities')">‚öΩ</button>
                        <button class="emoji-category" onclick="showEmojiCategory('objects')">üí°</button>
                        <button class="emoji-category" onclick="showEmojiCategory('flags')">üè≥Ô∏è</button>
                    </div>
                    <div class="emoji-grid" id="emojiGrid">
                        <!-- Emojis will be populated by JavaScript -->
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Media Viewer Modal -->
<div id="mediaViewer" class="media-viewer-modal" style="display: none;" onclick="closeMediaViewer()">
    <div class="media-viewer-content">
        <img id="viewerImage" style="display: none;">
        <video id="viewerVideo" style="display: none;" controls></video>
        <button class="media-viewer-close" onclick="closeMediaViewer()">√ó</button>
    </div>
</div>

<!-- Invite Link Modal -->
<div id="inviteLinkModal" class="modal-overlay" style="display: none;" onclick="closeInviteLinkModalOutside(event)">
    <div class="modal-container" onclick="event.stopPropagation()">
        <div class="modal-header">
            <h3>üì® Share Invite Link</h3>
            <button class="modal-close-btn" onclick="closeInviteLinkModal()">&times;</button>
        </div>
        <div class="modal-body">
            <p>Share this link to invite people to join <strong>{{ chat.name }}</strong>:</p>
            <div class="invite-link-container">
                <input type="text" id="shareInviteLink" class="invite-link-input" readonly 
                       value="{{ request.build_absolute_uri }}{% url 'join_group' chat.invite_code %}">
                <button onclick="copyShareLink()" class="btn btn--primary copy-btn">üìã Copy</button>
            </div>
            <div class="modal-footer">
                <button onclick="closeInviteLinkModal()" class="btn btn--secondary">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Group Modal (available on chat page so navbar Create works without leaving) -->
<div id="createGroupModal" class="modal-overlay" style="display: none;" onclick="closeCreateGroupModal(event)">
    <div class="modal-container" style="max-width: 520px;" onclick="event.stopPropagation()">
        <div class="modal-header">
            <h3>üë• Create Group</h3>
            <button class="modal-close-btn" onclick="closeCreateGroupModal()">&times;</button>
        </div>
        <div class="modal-body">
            <form id="createGroupForm" onsubmit="submitCreateGroupFromChat(event)">
                <label for="groupName">Group Name</label>
                <input type="text" id="groupName" name="name" maxlength="100" placeholder="Study buddies" required>

                <label for="groupDescription">Description (optional)</label>
                <textarea id="groupDescription" name="description" rows="3" placeholder="What is this group about?"></textarea>

                <label for="maxParticipants">Max participants</label>
                <input type="number" id="maxParticipants" name="max_participants" min="2" max="500" value="50">

                <label class="checkbox-inline">
                    <input type="checkbox" id="isPublic" name="is_public" checked> Make group public
                </label>

                <div class="modal-footer" style="justify-content: flex-end; gap: 10px;">
                    <button type="button" class="btn btn--secondary" onclick="closeCreateGroupModal()">Cancel</button>
                    <button type="submit" class="btn btn--primary">Create Group</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Group Created Confirmation Modal -->
<div id="groupCreatedModal" class="modal-overlay" style="display: none;" onclick="closeGroupCreatedModal(event)">
    <div class="modal-container" style="max-width: 480px;" onclick="event.stopPropagation()">
        <div class="modal-header">
            <h3>üéâ Group Created</h3>
            <button class="modal-close-btn" onclick="closeGroupCreatedModal()">&times;</button>
        </div>
        <div class="modal-body">
            <p>Your group <strong id="createdGroupName"></strong> is ready.</p>
            <label for="createdInviteLink">Invite link</label>
            <div class="invite-link-container">
                <input type="text" id="createdInviteLink" class="invite-link-input" readonly value="">
                <button type="button" class="btn btn--primary copy-btn" onclick="copyCreatedInviteLink()">üìã Copy</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: flex-end; gap: 10px;">
            <button type="button" class="btn btn--secondary" onclick="closeGroupCreatedModal()">Close</button>
            <button type="button" class="btn btn--primary" onclick="goToCreatedGroup()">Open Group</button>
        </div>
    </div>
</div>

<!-- Edit Message Modal -->
<div id="editMessageModal" class="edit-message-modal">
    <div class="edit-modal-content" onclick="event.stopPropagation()">
        <div class="edit-modal-header">
            <h3>‚úèÔ∏è Edit Message</h3>
            <button class="edit-modal-close" onclick="closeEditModal()">&times;</button>
        </div>
        <textarea id="editMessageText" class="edit-message-textarea" placeholder="Edit your message..."></textarea>
        <p id="editTimeRemaining" style="font-size: 0.8rem; color: #64748b; margin-bottom: 16px;"></p>
        <div class="edit-modal-actions">
            <button class="edit-modal-btn cancel" onclick="closeEditModal()">Cancel</button>
            <button class="edit-modal-btn save" onclick="saveEditedMessage()">Save Changes</button>
        </div>
    </div>
</div>

<!-- WhatsApp-style Delete Modal -->
<div id="deleteModal" class="delete-modal-overlay">
    <div class="delete-modal">
        <div class="delete-modal-header">
            <span class="delete-modal-icon">üóëÔ∏è</span>
            <h3>Delete message?</h3>
        </div>
        <div class="delete-modal-body">
            <p id="deleteModalText">Choose how you want to delete this message</p>
        </div>
        <div class="delete-modal-actions">
            <button class="delete-modal-btn delete-for-me" onclick="confirmDeleteForMe()">
                <span class="btn-icon">üë§</span>
                Delete for me
            </button>
            <button class="delete-modal-btn delete-for-everyone" id="deleteForEveryoneBtn" onclick="confirmDeleteForEveryone()">
                <span class="btn-icon">üë•</span>
                Delete for everyone
            </button>
            <button class="delete-modal-btn cancel" onclick="closeDeleteModal()">
                Cancel
            </button>
        </div>
    </div>
</div>

<!-- Instagram-style Reaction Picker -->
<div id="reactionPicker" class="reaction-picker-overlay" style="display: none;" onclick="closeReactionPicker()">
    <div class="reaction-picker-container" onclick="event.stopPropagation()">
        <div class="reaction-picker-emojis">
            <button class="reaction-emoji" onclick="sendReaction('‚ù§Ô∏è')" title="Love">‚ù§Ô∏è</button>
            <button class="reaction-emoji" onclick="sendReaction('üòÇ')" title="Haha">üòÇ</button>
            <button class="reaction-emoji" onclick="sendReaction('üòÆ')" title="Wow">üòÆ</button>
            <button class="reaction-emoji" onclick="sendReaction('üò¢')" title="Sad">üò¢</button>
            <button class="reaction-emoji" onclick="sendReaction('üò°')" title="Angry">üò°</button>
            <button class="reaction-emoji" onclick="sendReaction('üëç')" title="Like">üëç</button>
            <button class="reaction-emoji" onclick="sendReaction('üî•')" title="Fire">üî•</button>
            <button class="reaction-emoji" onclick="sendReaction('üéâ')" title="Celebrate">üéâ</button>
        </div>
    </div>
</div>

<!-- Group Settings Modal -->
{% if chat.chat_type == 'group' %}
<div id="groupSettingsModal" class="modal-overlay" style="display: none;" onclick="closeGroupSettingsOutside(event)">
    <div class="group-settings-container" onclick="event.stopPropagation()">
        <div class="group-settings-header">
            <h3><i data-lucide="users"></i> Group Settings</h3>
            <button class="modal-close-btn" onclick="closeGroupSettings()">&times;</button>
        </div>
        
        <div class="group-settings-body">
            <!-- Group Info Section -->
            <div class="group-info-section">
                <div class="group-avatar-large">
                    <i data-lucide="users" class="group-icon-large"></i>
                </div>
                <div id="groupNameDisplay" class="group-name-large">{{ chat.name }}</div>
                <div class="group-meta">
                    <span id="groupMemberCount">{{ chat.participant_count }} member{{ chat.participant_count|pluralize }}</span>
                    <span class="separator">‚Ä¢</span>
                    <span>Created {{ chat.created_at|date:"M d, Y" }}</span>
                </div>
                <div id="groupDescriptionDisplay" class="group-description">
                    {% if chat.description %}{{ chat.description }}{% else %}<em>No description</em>{% endif %}
                </div>
            </div>
            
            <!-- Quick Actions -->
            <div class="group-actions-section">
                <button onclick="showShareInviteLink()" class="group-action-btn">
                    <i data-lucide="link"></i>
                    <span>Share Invite Link</span>
                </button>
                {% if is_admin %}
                <button onclick="showEditGroupForm()" class="group-action-btn">
                    <i data-lucide="edit-2"></i>
                    <span>Edit Group</span>
                </button>
                {% endif %}
            </div>
            
            <!-- Edit Group Form (hidden by default) -->
            {% if is_admin %}
            <div id="editGroupForm" class="edit-group-form" style="display: none;">
                <h4>Edit Group Settings</h4>
                <div class="form-group">
                    <label for="editGroupName">Group Name</label>
                    <input type="text" id="editGroupName" value="{{ chat.name }}" maxlength="100">
                </div>
                <div class="form-group">
                    <label for="editGroupDescription">Description</label>
                    <textarea id="editGroupDescription" maxlength="500" rows="3">{{ chat.description|default_if_none:"" }}</textarea>
                </div>
                <div class="form-group">
                    <label for="editMaxParticipants">Max Participants</label>
                    <input type="number" id="editMaxParticipants" value="{{ chat.max_participants }}" min="2" max="500">
                </div>
                <div class="form-group checkbox-group">
                    <label>
                        <input type="checkbox" id="editIsPublic" {% if chat.is_public %}checked{% endif %}>
                        <span>Public Group (anyone can join without approval)</span>
                    </label>
                </div>
                <div class="form-actions">
                    <button onclick="hideEditGroupForm()" class="btn btn--secondary">Cancel</button>
                    <button onclick="saveGroupSettings()" class="btn btn--primary">Save Changes</button>
                </div>
            </div>
            {% endif %}
            
            <!-- Members Section -->
            <div class="group-members-section">
                <div class="section-header">
                    <h4><i data-lucide="users"></i> <span id="membersCountLabel">{{ chat.participant_count }} Members</span></h4>
                </div>
                <div id="membersList" class="members-list">
                    <!-- Members will be loaded via JavaScript -->
                    <div class="loading-members">
                        <i data-lucide="loader" class="spin"></i> Loading members...
                    </div>
                </div>
            </div>
            
            <!-- Danger Zone -->
            <div class="group-danger-section">
                <button onclick="confirmLeaveGroup()" class="btn btn--danger leave-group-btn">
                    <i data-lucide="log-out"></i>
                    Leave Group
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Leave Group Confirmation Modal -->
<div id="leaveGroupModal" class="modal-overlay" style="display: none;" onclick="closeLeaveGroupModal()">
    <div class="confirm-modal-container" onclick="event.stopPropagation()">
        <div class="confirm-modal-icon">‚ö†Ô∏è</div>
        <h3>Leave Group?</h3>
        <p id="leaveGroupMessage">Are you sure you want to leave <strong>{{ chat.name }}</strong>?</p>
        {% if is_admin %}
        <p class="admin-warning">As the admin, if you leave, admin rights will be transferred to another member.</p>
        {% endif %}
        <div class="confirm-modal-actions">
            <button onclick="closeLeaveGroupModal()" class="btn btn--secondary">Cancel</button>
            <button onclick="executeLeaveGroup()" class="btn btn--danger">Leave Group</button>
        </div>
    </div>
</div>

<!-- Remove Member Confirmation Modal -->
<div id="removeMemberModal" class="modal-overlay" style="display: none;" onclick="closeRemoveMemberModal()">
    <div class="confirm-modal-container" onclick="event.stopPropagation()">
        <div class="confirm-modal-icon">üö´</div>
        <h3>Remove Member?</h3>
        <p id="removeMemberMessage">Are you sure you want to remove this member?</p>
        <div class="confirm-modal-actions">
            <button onclick="closeRemoveMemberModal()" class="btn btn--secondary">Cancel</button>
            <button onclick="executeRemoveMember()" class="btn btn--danger">Remove</button>
        </div>
    </div>
</div>
{% endif %}

<!-- P2P File Share Modal -->
<div id="p2pFileShareModal" class="modal-overlay" style="display: none;" onclick="closeP2PModal(event)">
    <div class="p2p-modal-container" onclick="event.stopPropagation()">
        <div class="p2p-modal-header">
            <h3><i data-lucide="share-2"></i> P2P File Share</h3>
            <span class="p2p-badge">No Server Upload</span>
            <button class="modal-close-btn" onclick="closeP2PFileShare()">&times;</button>
        </div>
        
        <div class="p2p-modal-body">
            <!-- Step 1: Select File -->
            <div id="p2pStep1" class="p2p-step">
                <div class="p2p-info-banner">
                    <i data-lucide="info"></i>
                    <p>Share files directly with other users. Files are transferred peer-to-peer without touching the server. <strong>Unlimited file size!</strong></p>
                </div>
                {% if chat.chat_type == 'private' and other_participants %}
                <div class="p2p-info-banner p2p-auto-recipient">
                    <i data-lucide="user-check"></i>
                    <p>Sending directly to {{ other_participants.0.full_name }}. They must be online to receive.</p>
                </div>
                {% endif %}
                
                <div class="p2p-file-select" onclick="document.getElementById('p2pFileInput').click()">
                    <i data-lucide="upload-cloud" class="p2p-upload-icon"></i>
                    <p>Click to select a file</p>
                    <span class="p2p-hint">Any file type ‚Ä¢ No size limit</span>
                </div>
                <input type="file" id="p2pFileInput" style="display: none;" onchange="handleP2PFileSelect(event)">
                
                <div id="p2pSelectedFile" class="p2p-selected-file" style="display: none;">
                    <div class="p2p-file-info">
                        <i data-lucide="file" class="p2p-file-icon"></i>
                        <div class="p2p-file-details">
                            <span id="p2pFileName" class="p2p-file-name">filename.ext</span>
                            <span id="p2pFileSize" class="p2p-file-size">0 MB</span>
                        </div>
                    </div>
                    <button onclick="clearP2PFile()" class="p2p-remove-file">
                        <i data-lucide="x"></i>
                    </button>
                </div>
            </div>
            
            <!-- Step 2: Select Recipient -->
            <div id="p2pStep2" class="p2p-step" style="display: none;">
                <div class="p2p-step2-header">
                    <h4>Select Recipient</h4>
                    <button type="button" class="p2p-refresh-btn" onclick="loadP2PRecipients()" title="Refresh list">
                        <i data-lucide="refresh-cw"></i>
                    </button>
                </div>
                <p class="p2p-step2-note">Status updates automatically every 3 seconds</p>
                <div id="p2pRecipientList" class="p2p-recipient-list">
                    <!-- Recipients will be loaded dynamically -->
                </div>
            </div>
            
            <!-- Step 3: Transfer Progress -->
            <div id="p2pStep3" class="p2p-step" style="display: none;">
                <div class="p2p-transfer-status">
                    <div id="p2pStatusIcon" class="p2p-status-icon connecting">
                        <i data-lucide="wifi"></i>
                    </div>
                    <h4 id="p2pStatusText">Connecting...</h4>
                    <p id="p2pStatusDesc">Establishing peer-to-peer connection</p>
                </div>
                
                <div class="p2p-progress-container">
                    <div class="p2p-progress-bar">
                        <div id="p2pProgressFill" class="p2p-progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="p2p-progress-info">
                        <span id="p2pProgressPercent">0%</span>
                        <span id="p2pTransferSpeed">-- MB/s</span>
                    </div>
                </div>
                
                <div id="p2pTransferDetails" class="p2p-transfer-details">
                    <div class="p2p-detail-row">
                        <span>File:</span>
                        <span id="p2pTransferFileName">--</span>
                    </div>
                    <div class="p2p-detail-row">
                        <span>Size:</span>
                        <span id="p2pTransferFileSize">--</span>
                    </div>
                    <div class="p2p-detail-row">
                        <span>Transferred:</span>
                        <span id="p2pTransferred">0 MB</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="p2p-modal-footer">
            <button id="p2pCancelBtn" onclick="cancelP2PTransfer()" class="btn btn--secondary">Cancel</button>
            <button id="p2pNextBtn" onclick="p2pNextStep()" class="btn btn--primary" disabled>
                <span id="p2pNextBtnText">Select File</span>
                <i data-lucide="arrow-right"></i>
            </button>
        </div>
    </div>
</div>

<!-- P2P Incoming File Request Modal -->
<div id="p2pIncomingModal" class="modal-overlay" style="display: none;">
    <div class="p2p-incoming-container">
        <div class="p2p-incoming-header">
            <i data-lucide="download-cloud" class="p2p-incoming-icon"></i>
            <h3>Incoming File</h3>
        </div>
        <div class="p2p-incoming-body">
            <div class="p2p-incoming-sender">
                <img id="p2pSenderAvatar" src="" alt="" class="p2p-sender-avatar">
                <span id="p2pSenderName">Someone</span>
            </div>
            <p>wants to send you a file:</p>
            <div class="p2p-incoming-file">
                <i data-lucide="file"></i>
                <div class="p2p-incoming-file-info">
                    <span id="p2pIncomingFileName" class="p2p-incoming-file-name">file.ext</span>
                    <span id="p2pIncomingFileSize" class="p2p-incoming-file-size">0 MB</span>
                </div>
            </div>
        </div>
        <div class="p2p-incoming-actions">
            <button onclick="rejectP2PFile()" class="btn btn--danger">
                <i data-lucide="x"></i> Decline
            </button>
            <button onclick="acceptP2PFile()" class="btn btn--primary">
                <i data-lucide="check"></i> Accept
            </button>
        </div>
    </div>
</div>

<!-- P2P Receiving Progress Modal -->
<div id="p2pReceivingModal" class="modal-overlay" style="display: none;">
    <div class="p2p-receiving-container">
        <div class="p2p-receiving-header">
            <h3><i data-lucide="download"></i> Receiving File</h3>
        </div>
        <div class="p2p-receiving-body">
            <div class="p2p-receiving-file-info">
                <i data-lucide="file" class="p2p-receiving-file-icon"></i>
                <span id="p2pReceivingFileName">filename.ext</span>
            </div>
            <div class="p2p-progress-container">
                <div class="p2p-progress-bar">
                    <div id="p2pReceivingProgressFill" class="p2p-progress-fill" style="width: 0%"></div>
                </div>
                <div class="p2p-progress-info">
                    <span id="p2pReceivingPercent">0%</span>
                    <span id="p2pReceivingSpeed">-- MB/s</span>
                </div>
            </div>
            <p id="p2pReceivingStatus">Receiving...</p>
        </div>
        <div class="p2p-receiving-actions">
            <button onclick="cancelP2PReceive()" class="btn btn--danger">Cancel</button>
        </div>
    </div>
</div>

<style>
    /* 3-dot Menu - Click to reveal horizontal toolbar */
.message-menu-container {
    position: absolute;
    top: 8px;
    z-index: 100;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease;
}

/* Show menu button on message hover */
.message:hover .message-menu-container,
.message-menu-container:hover,
.message-menu-container.active {
    opacity: 1;
    visibility: visible;
}

/* Position button: inside the bubble on the corner */
.message:not(.message--own) .message-menu-container {
    left: auto;
    right: 8px;
}

.message--own .message-menu-container {
    right: 8px;
    left: auto;
}

.message-menu-btn {
    background: rgba(255, 255, 255, 0.9);
    border: none;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s ease;
    gap: 2px;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(4px);
}

.message--own .message-menu-btn {
    background: rgba(255, 255, 255, 0.25);
}

.message--own .message-menu-btn::before,
.message--own .message-menu-btn::after,
.message--own .message-menu-btn span {
    background: rgba(255, 255, 255, 0.9);
}

.message-menu-btn:hover {
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.message--own .message-menu-btn:hover {
    background: rgba(255, 255, 255, 0.4);
}

/* Horizontal dots */
.message-menu-btn::before,
.message-menu-btn::after,
.message-menu-btn span {
    content: '';
    width: 3px;
    height: 3px;
    background: #64748b;
    border-radius: 50%;
}

/* Horizontal Action Bar - Professional WhatsApp-style - Fixed positioning */
.message-menu {
    display: none;
    position: fixed;
    flex-direction: row;
    align-items: center;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.1);
    padding: 8px;
    z-index: 10000;
    white-space: nowrap;
    right: auto !important;
    bottom: auto !important;
}

.message-menu.show {
    display: flex;
    animation: menuPopIn 0.15s ease-out;
}

@keyframes menuPopIn {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

/* On small screens, center the menu */
@media (max-width: 480px) {
    .message-menu-container {
        opacity: 1;
        visibility: visible;
    }
    
    .message-menu-btn {
        width: 22px;
        height: 22px;
    }
    
    .message-menu-btn::before,
    .message-menu-btn::after,
    .message-menu-btn span {
        width: 2.5px;
        height: 2.5px;
    }
    
    .menu-action {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
    }
}

/* Menu action buttons - Clean professional style */
.menu-action {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 38px;
    height: 38px;
    cursor: pointer;
    transition: background-color 0.15s ease;
    font-size: 1.1rem;
    border-radius: 8px;
    color: #374151;
}

.menu-action:hover {
    background: #f3f4f6;
}

.menu-action:active {
    background: #e5e7eb;
}

/* WhatsApp-style Delete Modal */
.delete-modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 9999;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(4px);
}

.delete-modal-overlay.show {
    display: flex;
}

.delete-modal {
    background: #ffffff;
    border-radius: 16px;
    width: 90%;
    max-width: 340px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    overflow: hidden;
    animation: modalSlideIn 0.25s ease-out;
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

.delete-modal-header {
    padding: 24px 24px 12px;
    text-align: center;
}

.delete-modal-icon {
    font-size: 2.5rem;
    display: block;
    margin-bottom: 8px;
}

.delete-modal-header h3 {
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
}

.delete-modal-body {
    padding: 0 24px 20px;
    text-align: center;
}

.delete-modal-body p {
    margin: 0;
    font-size: 0.9rem;
    color: #6b7280;
}

.delete-modal-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 0 16px 16px;
}

.delete-modal-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
    padding: 14px 20px;
    border: none;
    border-radius: 12px;
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.delete-modal-btn .btn-icon {
    font-size: 1.1rem;
}

.delete-modal-btn.delete-for-me {
    background: #f3f4f6;
    color: #374151;
}

.delete-modal-btn.delete-for-me:hover {
    background: #e5e7eb;
}

.delete-modal-btn.delete-for-everyone {
    background: #ef4444;
    color: #ffffff;
}

.delete-modal-btn.delete-for-everyone:hover {
    background: #dc2626;
}

.delete-modal-btn.delete-for-everyone:disabled {
    background: #d1d5db;
    color: #9ca3af;
    cursor: not-allowed;
    display: none;
}

.delete-modal-btn.cancel {
    background: transparent;
    color: #6b7280;
    border: 1px solid #e5e7eb;
}

.delete-modal-btn.cancel:hover {
    background: #f9fafb;
    color: #374151;
}

/* Reply Indicator Styling - Clickable reply bubbles */
.reply-indicator {
    background: rgba(102, 126, 234, 0.1);
    border-left: 3px solid #667eea;
    padding: 8px 12px;
    margin-bottom: 8px;
    border-radius: 0 8px 8px 0;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.reply-indicator:hover {
    background: rgba(102, 126, 234, 0.2);
    transform: translateX(2px);
}

.reply-indicator .reply-line {
    width: 3px;
    min-height: 100%;
    background: #667eea;
    border-radius: 2px;
    flex-shrink: 0;
}

.reply-indicator .reply-content {
    font-size: 0.85rem;
    color: #4a5568;
    line-height: 1.4;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.reply-indicator .reply-content strong {
    color: #667eea;
    font-weight: 600;
}

.message--own .reply-indicator {
    background: rgba(255, 255, 255, 0.2);
    border-left-color: rgba(255, 255, 255, 0.6);
}

.message--own .reply-indicator:hover {
    background: rgba(255, 255, 255, 0.3);
}

.message--own .reply-indicator .reply-content {
    color: rgba(255, 255, 255, 0.9);
}

.message--own .reply-indicator .reply-content strong {
    color: #ffffff;
}

/* Reply reference visual (alternative styling) */
.reply-reference {
    background: rgba(255, 255, 255, 0.07);
    border-left: 3px solid #00CED1;
    padding: 6px 10px;
    margin-bottom: 5px;
    border-radius: 6px;
    font-size: 13px;
    color: #ccc;
}

.reply-line {
    width: 2px;
    height: 100%;
    position: absolute;
    left: 0;
}

.message-bubble {
    position: relative;
}

/* Highlighted message animation when scrolled to */
.message-highlight {
    animation: highlightPulse 2s ease-out;
}

@keyframes highlightPulse {
    0% {
        background-color: rgba(102, 126, 234, 0.3);
        transform: scale(1.02);
    }
    50% {
        background-color: rgba(102, 126, 234, 0.2);
    }
    100% {
        background-color: transparent;
        transform: scale(1);
    }
}

/* Enhanced Chat Layout - Responsive Design with Original White Theme Colors */
.main-container-chat {
    display: flex;
    height: 100vh;
    background: #ffffff;
    overflow: hidden;
    position: relative;
}

/* Enhanced Sidebar */
.sidebar-enhanced-chat {
    width: 300px;
    min-width: 300px;
    background: #ffffff;
    border-right: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    position: relative;
    z-index: 100;
    transition: all 0.3s ease;
    flex-shrink: 0;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

/* Mobile Sidebar Overlay */
.sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 150;
    backdrop-filter: blur(4px);
}

/* Sidebar Header */
.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid #e2e8f0;
    flex-shrink: 0;
    background: #f8fafc;
}

.logo {
    margin: 0 0 1rem 0;
    font-size: 1.8rem;
    font-weight: 700;
    color: #667eea;
    text-align: center;
}

.user-info-compact {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background: #ffffff;
    border-radius: 0.75rem;
    transition: all 0.2s ease;
    border: 1px solid #e2e8f0;
}

.user-info-compact:hover {
    background: #f1f5f9;
    border-color: #cbd5e1;
}

.user-avatar-small {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    margin-right: 0.75rem;
    font-size: 0.9rem;
    flex-shrink: 0;
}

/* Profile Avatar Images */
.profile-avatar-small {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.profile-avatar-header {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.profile-avatar-tiny {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* Avatar Fallback Styles */
.avatar-fallback,
.avatar-fallback-small,
.avatar-fallback-tiny,
.avatar-fallback-header,
.avatar-fallback-large {
    display: none;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    font-weight: 700;
    border-radius: 50%;
    text-transform: uppercase;
}

.avatar-fallback,
.avatar-fallback-small {
    font-size: 0.85rem;
}

.avatar-fallback-tiny {
    font-size: 0.7rem;
}

.avatar-fallback-header {
    font-size: 1.1rem;
}

.avatar-fallback-large {
    font-size: 1.5rem;
}

.user-details-small {
    flex: 1;
    min-width: 0;
}

.user-name-small {
    font-weight: 600;
    font-size: 0.95rem;
    margin-bottom: 0.25rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #1e293b;
}

.user-status-small {
    color: #64748b;
    font-size: 0.8rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Sidebar Navigation */
.sidebar-nav-compact {
    padding: 1rem;
    display: flex;
    gap: 0.5rem;
    border-bottom: 1px solid #e2e8f0;
    flex-shrink: 0;
}

.nav-item-compact {
    display: flex;
    align-items: center;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    text-decoration: none;
    color: #64748b;
    font-size: 0.9rem;
    flex: 1;
    justify-content: center;
    transition: all 0.2s ease;
    white-space: nowrap;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
}

.nav-item-compact:hover {
    background: #e0e7ff;
    color: #667eea;
    border-color: #c7d2fe;
    transform: translateY(-1px);
}

.nav-icon {
    margin-right: 0.5rem;
    font-size: 1rem;
}

/* Sidebar Sections */
.sidebar-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    margin-bottom: 0.5rem;
}

.sidebar-section-title {
    padding: 1rem 1rem 0.5rem;
    font-size: 1rem;
    font-weight: 600;
    color: #1e293b;
    flex-shrink: 0;
}

.sidebar-chat-list,
.sidebar-users-list {
    flex: 1;
    overflow-y: auto;
    padding: 0 1rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
}

.sidebar-chat-list::-webkit-scrollbar,
.sidebar-users-list::-webkit-scrollbar {
    width: 4px;
}

.sidebar-chat-list::-webkit-scrollbar-track,
.sidebar-users-list::-webkit-scrollbar-track {
    background: transparent;
}

.sidebar-chat-list::-webkit-scrollbar-thumb,
.sidebar-users-list::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 2px;
}

/* Chat Items */
.sidebar-chat-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    border-radius: 0.75rem;
    text-decoration: none;
    color: inherit;
    margin-bottom: 0.5rem;
    transition: all 0.2s ease;
    position: relative;
    background: #ffffff;
    border: 1px solid #f1f5f9;
}

.sidebar-chat-item:hover {
    background: #f8fafc;
    border-color: #e2e8f0;
    transform: translateX(2px);
}

.sidebar-chat-item.active {
    background: #e0e7ff;
    border-color: #c7d2fe;
    border-left: 3px solid #667eea;
}

.chat-avatar-small {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    margin-right: 0.75rem;
    font-size: 0.9rem;
    flex-shrink: 0;
}

.group-avatar {
    background: linear-gradient(135deg, #10b981, #059669);
}

.chat-info-small {
    flex: 1;
    min-width: 0;
}

.chat-name-small {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #1e293b;
}

.admin-badge {
    font-size: 0.7rem;
    flex-shrink: 0;
}

.chat-meta {
    color: #64748b;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* User Items */
.sidebar-user-item {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.5rem;
    margin-bottom: 0.25rem;
    transition: all 0.2s ease;
}

.sidebar-user-item:hover {
    background: #f8fafc;
}

.user-avatar-tiny {
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    margin-right: 0.5rem;
    font-size: 0.8rem;
    flex-shrink: 0;
}

.user-info-tiny {
    flex: 1;
    min-width: 0;
}

.user-name-tiny {
    font-size: 0.85rem;
}

.profile-link-small {
    color: #667eea;
    text-decoration: none;
    font-weight: 500;
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.profile-link-small:hover {
    text-decoration: underline;
}

/* Sidebar Footer */
.sidebar-footer-compact {
    padding: 1rem;
    border-top: 1px solid #e2e8f0;
    flex-shrink: 0;
}

/* Chat Content Area */
.chat-content-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height for mobile */
    background: #f8fafc;
    position: relative;
}

/* Mobile Header Controls */
.mobile-header-left {
    display: none;
    align-items: center;
    margin-right: 0.5rem;
}

.mobile-back-btn,
.mobile-menu-btn {
    background: #ffffff;
    border: 1px solid #e2e8f0;
    font-size: 1.5rem;
    font-weight: bold;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 0.5rem;
    color: #1e293b;
    transition: all 0.2s ease;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mobile-menu-btn {
    display: none;
}

.mobile-back-btn:hover,
.mobile-menu-btn:hover {
    background: #f8fafc;
    border-color: #cbd5e1;
    transform: scale(1.05);
}

.mobile-back-btn {
    color: #667eea;
}

/* Desktop only elements */
.desktop-only {
    display: inline-flex;
}

/* Enhanced Chat Header */
.chat-header-enhanced {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    background: #ffffff;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    min-height: 80px;
    flex-shrink: 0;
    position: sticky;
    top: 0;
    z-index: 100;
}

.chat-title-section {
    display: flex;
    align-items: center;
    flex: 1;
    min-width: 0;
}

.chat-avatar-header {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1.2rem;
    margin-right: 1rem;
    flex-shrink: 0;
}

.chat-info-header {
    flex: 1;
    min-width: 0;
}

.chat-info-header h2 {
    margin: 0 0 0.25rem 0;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 1.3rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #1e293b;
}

.admin-badge-header {
    background: #fbbf24;
    color: #92400e;
    padding: 0.25rem 0.5rem;
    border-radius: 0.5rem;
    font-size: 0.7rem;
    font-weight: 600;
    flex-shrink: 0;
}

.chat-status-header {
    color: #64748b;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    white-space: nowrap;
    overflow: hidden;
    flex-wrap: wrap;
}

.member-count {
    font-weight: 500;
}

.status-online,
.status-offline {
    font-size: 0.8rem;
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    transition: all 0.3s ease;
}

.status-online {
    color: #059669;
    background: rgba(5, 150, 105, 0.1);
}

.status-offline {
    color: #6b7280;
    background: rgba(107, 114, 128, 0.1);
}

.online-dot {
    width: 8px;
    height: 8px;
    color: #10b981;
    fill: #10b981;
    animation: pulse-online 2s infinite;
}

.offline-dot {
    width: 8px;
    height: 8px;
    color: #9ca3af;
    fill: #9ca3af;
}

@keyframes pulse-online {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.btn-link {
    background: none;
    border: none;
    color: #667eea;
    cursor: pointer;
    font-size: 0.85rem;
    text-decoration: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
}

.btn-link:hover {
    background: #e0e7ff;
    text-decoration: underline;
    transform: translateY(-1px);
}

.chat-actions-header {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    flex-shrink: 0;
}

/* Messages Container - WhatsApp Style */
.messages-container-enhanced {
    flex: 1;
    padding: 1.5rem;
    overflow-y: auto;
    overflow-x: hidden;
    background: #f8fafc;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    min-height: 0;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
}

.messages-container-enhanced::-webkit-scrollbar {
    width: 6px;
}

.messages-container-enhanced::-webkit-scrollbar-track {
    background: transparent;
}

.messages-container-enhanced::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
}

/* Message Styling */
.message {
    display: flex;
    width: 100%;
    margin-bottom: 0.5rem;
    align-items: flex-end;
    justify-content: flex-start;
}

.message--own {
    justify-content: flex-end;
}

.message--system {
    justify-content: center;
    margin: 0.5rem 0;
}

/* Message Bubble */
.message-bubble {
    max-width: 70%;
    min-width: 100px;
    padding: 0.75rem 1rem;
    border-radius: 18px;
    position: relative;
    word-wrap: break-word;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
}

.message:not(.message--own):not(.message--system) .message-bubble {
    background: #ffffff;
    color: #1e293b;
    border-bottom-left-radius: 4px;
    margin-right: auto;
    border: 1px solid #e2e8f0;
}

.message--own .message-bubble {
    background: #667eea;
    color: white;
    border-bottom-right-radius: 4px;
    margin-left: auto;
}

.message--system .message-bubble {
    background: #e0e7ff;
    color: #3730a3;
    text-align: center;
    font-style: italic;
    padding: 0.5rem 1rem;
    border-radius: 12px;
    max-width: 80%;
    margin: 0 auto;
    border: 1px solid #c7d2fe;
}

/* Message Content */
.message-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.message-text {
    line-height: 1.4;
    margin: 0;
}

/* Hashtag and Mention Links in messages */
.hashtag-link {
    color: #667eea;
    text-decoration: none;
    font-weight: 600;
}

.hashtag-link:hover {
    text-decoration: underline;
}

.mention-link {
    color: #10b981;
    text-decoration: none;
    font-weight: 600;
}

.mention-link:hover {
    text-decoration: underline;
}

.message-time {
    font-size: 0.75rem;
    margin-top: 0.5rem;
    display: block;
}

.message:not(.message--own):not(.message--system) .message-time {
    color: #64748b;
    text-align: left;
}

.message--own .message-time {
    color: rgba(255, 255, 255, 0.8);
    text-align: right;
}

/* Read Receipts */
.read-receipt {
    margin-left: 4px;
    font-size: 0.8rem;
    opacity: 0.7;
}

.read-receipt.delivered {
    opacity: 0.9;
}

.read-receipt.read {
    color: #00CED1;
    opacity: 1;
}

/* Typing Indicator - Fixed position above input */
.typing-indicator-fixed {
    padding: 0.5rem 1rem;
    background: transparent;
}

.typing-bubble-content {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: #ffffff;
    padding: 8px 14px;
    border-radius: 18px;
    border-bottom-left-radius: 4px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.typing-dots-animated {
    display: flex;
    gap: 4px;
    align-items: center;
}

.typing-dots-animated span {
    width: 8px;
    height: 8px;
    background: #94a3b8;
    border-radius: 50%;
    animation: typingBounce 1.4s infinite ease-in-out both;
}

.typing-dots-animated span:nth-child(1) {
    animation-delay: -0.32s;
}

.typing-dots-animated span:nth-child(2) {
    animation-delay: -0.16s;
}

.typing-dots-animated span:nth-child(3) {
    animation-delay: 0s;
}

@keyframes typingBounce {
    0%, 80%, 100% {
        transform: scale(0.6);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

.typing-name {
    font-size: 0.8rem;
    color: #64748b;
    font-style: italic;
}

/* Starred message indicator */
.starred-indicator {
    color: #fbbf24;
    font-size: 0.75rem;
    margin-right: 4px;
}

/* Star button active state */
.star-btn.starred {
    background: #fef3c7 !important;
    transform: scale(1.1);
}

/* Toast Notification */
.toast-notification {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: #1f2937;
    color: #fff;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 0.9rem;
    z-index: 10000;
    opacity: 0;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.toast-notification.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

.toast-notification.error {
    background: #ef4444;
}

.toast-notification.success {
    background: #10b981;
}

/* Edited indicator styles */
.edited-indicator {
    font-size: 0.7rem;
    font-style: italic;
    opacity: 0.7;
    margin-left: 4px;
}

/* Pinned message badge */
.pinned-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #fff;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: 600;
    margin-left: 8px;
}

.pinned-badge svg {
    width: 12px;
    height: 12px;
}

/* Pinned message highlight */
.message.pinned-message {
    border-left: 3px solid #fbbf24;
    background: linear-gradient(to right, rgba(251, 191, 36, 0.1), transparent);
}

/* Pinned messages section at top of chat */
.pinned-messages-section {
    background: linear-gradient(135deg, #fef3c7, #fde68a);
    border-bottom: 1px solid #f59e0b;
    padding: 12px 16px;
    max-height: 150px;
    overflow-y: auto;
}

.pinned-messages-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    color: #92400e;
    margin-bottom: 8px;
    font-size: 0.875rem;
}

.pinned-messages-header svg {
    width: 16px;
    height: 16px;
}

.pinned-message-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.85);
    border-radius: 10px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid rgba(245, 158, 11, 0.2);
}

.pinned-message-item:hover {
    background: rgba(255, 255, 255, 1);
    transform: translateX(4px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.pinned-message-item:last-child {
    margin-bottom: 0;
}

.pinned-message-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    border-radius: 8px;
    flex-shrink: 0;
}

.pinned-message-icon svg {
    width: 16px;
    height: 16px;
    color: white;
}

.pinned-message-info {
    flex: 1;
    min-width: 0;
}

.pinned-message-sender {
    font-weight: 600;
    color: #667eea;
    font-size: 0.8rem;
    margin-bottom: 2px;
}

.pinned-message-content {
    font-size: 0.85rem;
    color: #1e293b;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 300px;
}

.pinned-message-arrow {
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
    flex-shrink: 0;
}

.pinned-message-arrow svg {
    width: 18px;
    height: 18px;
}

/* Pinned indicator on message */
.pinned-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.7rem;
    color: #f59e0b;
    font-weight: 600;
    margin-bottom: 4px;
}

.pinned-indicator .pin-icon {
    width: 12px;
    height: 12px;
}

.message--pinned {
    border-left: 3px solid #fbbf24;
    background: linear-gradient(to right, rgba(251, 191, 36, 0.1), transparent);
}

/* Message highlight animation */
.highlight-message {
    animation: highlightPulse 2s ease-out;
}

@keyframes highlightPulse {
    0% { background-color: rgba(102, 126, 234, 0.3); }
    100% { background-color: transparent; }
}

/* Edit message modal */
.edit-message-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.edit-message-modal.show {
    display: flex;
}

.edit-modal-content {
    background: white;
    border-radius: 16px;
    padding: 24px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.edit-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.edit-modal-header h3 {
    margin: 0;
    color: #1e293b;
    font-size: 1.25rem;
}

.edit-modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #64748b;
    padding: 0;
}

.edit-message-textarea {
    width: 100%;
    min-height: 100px;
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1rem;
    resize: vertical;
    margin-bottom: 16px;
    font-family: inherit;
}

.edit-message-textarea:focus {
    outline: none;
    border-color: #667eea;
}

.edit-modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.edit-modal-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.edit-modal-btn.cancel {
    background: #e2e8f0;
    color: #64748b;
}

.edit-modal-btn.cancel:hover {
    background: #cbd5e1;
}

.edit-modal-btn.save {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
}

.edit-modal-btn.save:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.sender-name {
    font-weight: 600;
    color: #667eea;
    font-size: 0.8rem;
    display: block;
    margin-bottom: 0.25rem;
}

.message--own .sender-name {
    display: none;
}

.system-message-icon {
    margin-right: 0.5rem;
}

/* Media in Messages */
.message-image,
.message-video {
    max-width: 250px;
    max-height: 200px;
    border-radius: 12px;
    margin: 0.25rem 0;
}

.message-image {
    cursor: pointer;
    transition: transform 0.2s ease;
}

.message-image:hover {
    transform: scale(1.02);
}

/* Message Input Container */
.message-input-container-enhanced {
    padding: 1.5rem;
    background: #ffffff;
    border-top: 1px solid #e2e8f0;
    flex-shrink: 0;
    position: relative;
}

.media-preview-area {
    background: #e0e7ff;
    border-radius: 0.75rem;
    padding: 1rem;
    margin-bottom: 1rem;
    position: relative;
    border: 1px solid #c7d2fe;
}

.media-preview-content {
    text-align: center;
}

.preview-media {
    max-width: 200px;
    max-height: 150px;
    border-radius: 0.5rem;
}

.media-preview-close {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    cursor: pointer;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.message-input-wrapper-enhanced {
    display: flex;
    align-items: flex-end;
    gap: 0.75rem;
    background: #f8fafc;
    border: 2px solid #e2e8f0;
    border-radius: 1.5rem;
    padding: 0.5rem;
    transition: all 0.2s ease;
}

.message-input-wrapper-enhanced:focus-within {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    background: #ffffff;
}

.input-actions-left {
    display: flex;
    gap: 0.5rem;
}

.action-btn {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 50%;
    transition: all 0.2s ease;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #64748b;
}

.action-btn:hover {
    background: #e2e8f0;
    color: #667eea;
    transform: scale(1.05);
}

.message-textarea-enhanced {
    flex: 1;
    border: none;
    outline: none;
    font-size: 1rem;
    font-family: inherit;
    resize: none;
    max-height: 120px;
    min-height: 40px;
    padding: 0.5rem;
    background: transparent;
    line-height: 1.4;
    color: #1e293b;
}

.message-textarea-enhanced::placeholder {
    color: #94a3b8;
}

.send-btn-enhanced {
    border-radius: 50%;
    width: 45px;
    height: 45px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    background: #667eea;
    border: none;
    color: white;
    position: relative;
}

.send-btn-enhanced:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    background: #5a67d8;
}

.send-btn-enhanced:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.send-icon {
    width: 20px;
    height: 20px;
    display: inline-block;
    vertical-align: middle;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* Spinning animation for loading state */
.spinning {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

/* Emoji Picker */
.emoji-picker {
    position: absolute;
    bottom: 100%;
    left: 0;
    right: 0;
    background: #ffffff;
    border: 1px solid #e2e8f0;
    border-radius: 1rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    margin-bottom: 0.5rem;
    max-height: 300px;
    overflow: hidden;
    z-index: 1000;
    animation: slideUpFadeIn 0.3s ease-out;
}

@keyframes slideUpFadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.emoji-categories {
    display: flex;
    justify-content: space-around;
    padding: 0.5rem;
    border-bottom: 1px solid #e2e8f0;
    background: #f8fafc;
}

.emoji-category {
    background: none;
    border: none;
    padding: 0.5rem;
    font-size: 1.2rem;
    cursor: pointer;
    border-radius: 0.5rem;
    transition: all 0.2s ease;
}

.emoji-category:hover,
.emoji-category.active {
    background: #e0e7ff;
    transform: scale(1.1);
}

.emoji-grid {
    padding: 1rem;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 0.5rem;
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
}

.emoji-grid::-webkit-scrollbar {
    width: 4px;
}

.emoji-grid::-webkit-scrollbar-track {
    background: transparent;
}

.emoji-grid::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 2px;
}

.emoji-item {
    padding: 0.5rem;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 0.5rem;
    text-align: center;
    transition: all 0.2s ease;
}

.emoji-item:hover {
    background: #e0e7ff;
    transform: scale(1.2);
}

/* Modals and Overlays */
.media-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    backdrop-filter: blur(4px);
}

.media-viewer-content {
    position: relative;
    max-width: 90%;
    max-height: 90%;
}

.media-viewer-content img,
.media-viewer-content video {
    max-width: 100%;
    max-height: 100%;
    border-radius: 0.5rem;
}

.media-viewer-close {
    position: absolute;
    top: -40px;
    right: 0;
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    font-size: 2rem;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.media-viewer-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

/* Modal Styling */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    backdrop-filter: blur(4px);
    animation: modalFadeIn 0.2s ease-out;
}

@keyframes modalFadeIn {
    from {
        opacity: 0;
        backdrop-filter: blur(0px);
    }
    to {
        opacity: 1;
        backdrop-filter: blur(4px);
    }
}

.modal-container {
    background: #ffffff;
    border-radius: 1rem;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow: hidden;
    animation: modalSlideIn 0.3s ease-out;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem 1rem;
    border-bottom: 1px solid #e2e8f0;
}

.modal-header h3 {
    margin: 0;
    font-size: 1.3rem;
    font-weight: 600;
    color: #1e293b;
}

.modal-close-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #64748b;
    padding: 0.5rem;
    border-radius: 0.5rem;
    transition: all 0.2s ease;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close-btn:hover {
    background: #fee2e2;
    color: #dc2626;
    transform: scale(1.1);
}

.modal-body {
    padding: 1.5rem 2rem;
}

.modal-body p {
    margin: 0 0 1.5rem 0;
    color: #1e293b;
    line-height: 1.5;
}

.invite-link-container {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    background: #f8fafc;
    padding: 1rem;
    border-radius: 0.75rem;
    border: 1px solid #e2e8f0;
    align-items: center;
}

.invite-link-input {
    flex: 1;
    background: transparent;
    border: none;
    outline: none;
    font-size: 0.9rem;
    color: #1e293b;
    padding: 0.5rem;
    border-radius: 0.5rem;
    font-family: monospace;
    word-break: break-all;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
}

/* Button Styles */
.btn {
    padding: 0.75rem 1.5rem;
    border: 1px solid transparent;
    border-radius: 0.5rem;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    text-decoration: none;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    transition: all 0.3s ease;
    transform: translate(-50%, -50%);
}

.btn:hover::before {
    width: 300px;
    height: 300px;
}

.btn--primary {
    background: #667eea;
    color: white;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.btn--primary:hover {
    background: #5a67d8;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

.btn--secondary {
    background: #f8fafc;
    color: #1e293b;
    border: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn--secondary:hover {
    background: #f1f5f9;
    border-color: #cbd5e1;
    transform: translateY(-2px);
}

.btn--warning {
    background: #fbbf24;
    color: #92400e;
    box-shadow: 0 2px 8px rgba(251, 191, 36, 0.3);
}

.btn--warning:hover {
    background: #f59e0b;
    transform: translateY(-2px);
}

.btn--danger {
    background: #dc2626;
    color: white;
    box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
}

.btn--danger:hover {
    background: #b91c1c;
    transform: translateY(-2px);
}

.btn--small {
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
}

.btn--full-width {
    width: 100%;
}

.btn-mini {
    padding: 0.375rem 0.75rem;
    border: none;
    border-radius: 0.5rem;
    cursor: pointer;
    font-size: 0.8rem;
    margin: 0 0.25rem;
    transition: all 0.2s ease;
}

.copy-btn {
    padding: 0.5rem 1rem !important;
    font-size: 0.9rem !important;
    border-radius: 0.5rem !important;
    white-space: nowrap;
    flex-shrink: 0;
}

/* Join Requests Panel */
.join-requests-panel {
    background: #fef3c7;
    border: 1px solid #fde68a;
    border-radius: 0.75rem;
    padding: 1rem;
    margin: 0 1.5rem 1rem;
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
        max-height: 0;
    }
    to {
        opacity: 1;
        transform: translateY(0);
        max-height: 500px;
    }
}

.join-request-item-chat {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem;
    background: #ffffff;
    border-radius: 0.5rem;
    margin-bottom: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
    border: 1px solid #f3f4f6;
}

.join-request-item-chat:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.request-user-info {
    display: flex;
    align-items: center;
    flex: 1;
}

.requester-avatar-small {
    width: 36px;
    height: 36px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    margin-right: 0.75rem;
    font-size: 0.8rem;
}

.requester-name-small {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
    color: #1e293b;
}

.request-message-small {
    color: #64748b;
    font-size: 0.8rem;
    font-style: italic;
    margin-bottom: 0.25rem;
}

.request-time-small {
    color: #64748b;
    font-size: 0.75rem;
}

.request-actions-small {
    display: flex;
    gap: 0.5rem;
}

/* Animation for new messages */
.message-fade-in {
    animation: fadeInUp 0.3s ease-out;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message-sending {
    opacity: 0.7;
    transform: scale(0.98);
    transition: all 0.2s ease;
}

/* RESPONSIVE DESIGN */

/* Large Tablets - 1024px and below */
@media (max-width: 1024px) {
    .sidebar-enhanced-chat {
        width: 280px;
        min-width: 280px;
    }
    
    .chat-header-enhanced {
        padding: 1rem 1.5rem;
    }
    
    .messages-container-enhanced {
        padding: 1rem;
    }
    
    .message-input-container-enhanced {
        padding: 1rem;
    }
}

/* Standard Tablets - 768px and below */
@media (max-width: 768px) {
    .main-container-chat {
        position: relative;
    }

    .sidebar-enhanced-chat {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 300px;
        z-index: 200;
        transform: translateX(-100%);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }

    .sidebar-enhanced-chat.show {
        transform: translateX(0);
    }

    .sidebar-overlay.show {
        display: block;
    }

    .chat-content-area {
        width: 100%;
        height: 100vh;
    }

    .mobile-header-left {
        display: flex;
    }
    
    .mobile-menu-btn {
        display: flex;
    }
    
    /* Hide desktop-only elements on mobile */
    .desktop-only {
        display: none !important;
    }

    .chat-header-enhanced {
        padding: 1rem;
        min-height: 70px;
    }

    .chat-title-section {
        margin-left: 0.5rem;
    }

    .chat-avatar-header {
        width: 45px;
        height: 45px;
        font-size: 1.1rem;
        margin-right: 0.75rem;
    }

    .chat-info-header h2 {
        font-size: 1.1rem;
    }

    .chat-status-header {
        font-size: 0.8rem;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .chat-actions-header {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-end;
    }

    .messages-container-enhanced {
        padding: 1rem;
    }

    .message-bubble {
        max-width: 85%;
    }

    .message-input-container-enhanced {
        padding: 1rem;
    }

    .emoji-picker {
        max-height: 250px;
    }

    .emoji-grid {
        grid-template-columns: repeat(6, 1fr);
        max-height: 150px;
    }

    .modal-container {
        width: 95%;
        margin: 1rem;
    }

    .modal-header,
    .modal-body {
        padding: 1rem 1.5rem;
    }

    .invite-link-container {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
    }

    .copy-btn {
        align-self: center;
        min-width: 120px;
    }
    
    /* Improve sidebar scrolling on tablets */
    .sidebar-chat-list,
    .sidebar-users-list {
        -webkit-overflow-scrolling: touch;
    }
}

/* Small Mobile - 480px and below */
@media (max-width: 480px) {
    .sidebar-enhanced-chat {
        width: 280px;
    }
    
    .mobile-back-btn,
    .mobile-menu-btn {
        font-size: 1.3rem;
        min-width: 40px;
        min-height: 40px;
        padding: 0.375rem;
    }

    .chat-header-enhanced {
        padding: 0.75rem;
        min-height: 65px;
    }

    .chat-avatar-header {
        width: 40px;
        height: 40px;
        font-size: 1rem;
        margin-right: 0.5rem;
    }

    .chat-info-header h2 {
        font-size: 1rem;
    }

    .chat-status-header {
        font-size: 0.75rem;
        gap: 0.25rem;
    }

    .admin-badge-header {
        font-size: 0.6rem;
        padding: 0.2rem 0.4rem;
    }

    .messages-container-enhanced {
        padding: 0.75rem;
    }

    .message-bubble {
        max-width: 90%;
        padding: 0.6rem 0.8rem;
    }

    .message-image, 
    .message-video {
        max-width: 200px;
        max-height: 150px;
    }

    .message-input-container-enhanced {
        padding: 0.5rem;
    }

    .message-input-wrapper-enhanced {
        gap: 0.25rem;
        padding: 0.25rem 0.5rem;
        border-radius: 1.25rem;
    }

    .input-actions-left {
        gap: 0;
    }

    .action-btn {
        min-width: 36px;
        min-height: 36px;
        font-size: 1rem;
        padding: 0.25rem;
    }
    
    .action-btn .action-icon {
        width: 20px;
        height: 20px;
    }

    .message-textarea-enhanced {
        min-height: 36px;
        padding: 0.375rem 0.5rem;
        font-size: 0.95rem;
    }

    .send-btn-enhanced {
        width: 36px;
        height: 36px;
        position: relative;
    }

    .send-icon {
        width: 16px;
        height: 16px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .emoji-categories {
        padding: 0.375rem;
        gap: 0.25rem;
    }

    .emoji-category {
        padding: 0.375rem;
        font-size: 1rem;
    }

    .emoji-grid {
        grid-template-columns: repeat(5, 1fr);
        padding: 0.75rem;
        gap: 0.375rem;
    }

    .emoji-item {
        padding: 0.375rem;
        font-size: 1.3rem;
    }

    .modal-container {
        width: 95%;
        margin: 0.5rem;
    }

    .modal-header,
    .modal-body {
        padding: 1rem;
    }

    .modal-header h3 {
        font-size: 1.1rem;
    }

    .invite-link-input {
        font-size: 0.8rem;
    }
    
    /* Adjust sidebar for smaller screens */
    .sidebar-header {
        padding: 0.75rem;
    }
    
    .logo {
        font-size: 1.6rem;
        margin-bottom: 0.75rem;
    }
    
    .user-info-compact {
        padding: 0.5rem;
    }
    
    .sidebar-nav-compact {
        padding: 0.75rem;
        gap: 0.25rem;
    }
    
    .nav-item-compact {
        padding: 0.375rem 0.75rem;
        font-size: 0.85rem;
    }
    
    .sidebar-section-title {
        padding: 0.75rem 0.75rem 0.375rem;
        font-size: 0.9rem;
    }
    
    .sidebar-chat-list,
    .sidebar-users-list {
        padding: 0 0.75rem;
    }
    
    .sidebar-footer-compact {
        padding: 0.75rem;
    }
}

/* Very Small Screens - 360px and below */
@media (max-width: 360px) {
    .sidebar-enhanced-chat {
        width: 280px;
    }
    
    .mobile-back-btn,
    .mobile-menu-btn {
        font-size: 1.2rem;
        min-width: 36px;
        min-height: 36px;
    }
    
    .chat-header-enhanced {
        padding: 0.5rem;
    }

    .chat-info-header h2 {
        font-size: 0.9rem;
    }

    .chat-status-header {
        font-size: 0.7rem;
    }

    .message-bubble {
        padding: 0.5rem 0.7rem;
        font-size: 0.9rem;
    }

    .message-textarea-enhanced {
        font-size: 0.9rem;
    }

    .emoji-grid {
        grid-template-columns: repeat(4, 1fr);
    }
    
    .action-btn {
        min-width: 34px;
        min-height: 34px;
        font-size: 0.95rem;
        padding: 0.2rem;
    }
    
    .input-actions-left {
        gap: 0;
    }
    
    .send-btn-enhanced {
        width: 34px;
        height: 34px;
        position: relative;
    }
    
    .send-icon {
        width: 16px;
        height: 16px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}

/* Landscape orientation adjustments */
@media (max-height: 500px) and (orientation: landscape) {
    .chat-header-enhanced {
        min-height: 55px;
        padding: 0.5rem 1rem;
    }

    .messages-container-enhanced {
        padding: 0.5rem 1rem;
    }

    .message-input-container-enhanced {
        padding: 0.5rem 1rem;
    }

    .emoji-picker {
        max-height: 180px;
    }

    .emoji-grid {
        max-height: 100px;
        grid-template-columns: repeat(8, 1fr);
    }
    
    .sidebar-enhanced-chat {
        width: 260px;
    }
}

/* Focus styles for accessibility */
.mobile-back-btn:focus,
.mobile-menu-btn:focus,
.action-btn:focus,
.btn:focus,
.emoji-category:focus,
.emoji-item:focus {
    outline: 2px solid #667eea;
    outline-offset: 2px;
}

/* High contrast mode */
@media (prefers-contrast: high) {
    .message-bubble {
        border: 2px solid;
    }
    
    .message:not(.message--own):not(.message--system) .message-bubble {
        border-color: #1e293b;
    }
    
    .message--own .message-bubble {
        border-color: white;
    }
}

@media (max-width: 320px) {
    html, body { overflow-x: hidden; }
    .chat-info-header h2,
    .user-name-small,
    .chat-name-small { font-size: .8rem; }
    .message-image, .message-video { max-width: 100%; height: auto; }
}

/* Typing Indicator Mobile */
@media (max-width: 768px) {
    .typing-indicator-bubble {
        padding: 0.25rem 0;
    }
    
    .typing-bubble-content {
        padding: 8px 12px;
        max-width: 180px;
    }
    
    .typing-dots-animated span {
        width: 6px;
        height: 6px;
    }
    
    .typing-name {
        font-size: 0.75rem;
    }
}

/* One-Time Messages */
.one-time-message {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.one-time-message:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

/* Sender's view - message opened */
.one-time-opened {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 1rem 1.5rem;
    background: #ffffff;
    color: #16a34a;
    border-radius: 12px;
    font-size: 0.95rem;
    font-weight: 500;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Sender's view - message not yet opened */
.one-time-pending {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 1rem 1.5rem;
    background: #ffffff;
    color: #667eea;
    border-radius: 12px;
    font-size: 0.95rem;
    font-weight: 500;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* One-time viewed state for receiver */
.one-time-viewed {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 1rem 1.5rem;
    background: #ffffff;
    color: #64748b;
    border-radius: 12px;
    font-size: 0.95rem;
    font-style: italic;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.one-time-icon {
    width: 18px;
    height: 18px;
}

.one-time-icon-small {
    width: 12px;
    height: 12px;
}

.one-time-sent-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 4px;
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.15);
    border-radius: 8px;
    width: fit-content;
}

.message:not(.message--own) .one-time-sent-indicator {
    color: rgba(0, 0, 0, 0.5);
    background: rgba(0, 0, 0, 0.05);
}

.one-time-text {
    font-weight: 500;
}

.consumed-icon {
    width: 16px;
    height: 16px;
}

/* One-Time Modal */
.one-time-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: modalFadeIn 0.2s ease;
}

.one-time-modal-content {
    background: white;
    border-radius: 12px;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}

.one-time-modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.one-time-modal-header h3 {
    margin: 0;
    color: #1e293b;
}

.one-time-modal-header button {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #64748b;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.2s ease;
}

.one-time-modal-header button:hover {
    background: #f1f5f9;
}

.one-time-modal-body {
    padding: 1.5rem;
    color: #334155;
    line-height: 1.6;
    white-space: pre-wrap;
}

@keyframes modalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Full-screen One-Time Message Viewer (WhatsApp style) */
.one-time-fullscreen-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000000;
    display: flex;
    flex-direction: column;
    z-index: 99999;
    animation: modalFadeIn 0.3s ease;
}

.one-time-fullscreen-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    background: rgba(0, 0, 0, 0.5);
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
}

.one-time-fullscreen-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: white;
    font-size: 0.9rem;
}

.one-time-fullscreen-info .one-time-icon {
    width: 18px;
    height: 18px;
}

.one-time-close-btn {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    font-size: 1.2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s ease;
}

.one-time-close-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.one-time-fullscreen-body {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4rem 1rem;
    overflow: auto;
}

.one-time-fullscreen-media {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 8px;
}

.one-time-fullscreen-text {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    padding: 2rem;
    border-radius: 16px;
    max-width: 600px;
    font-size: 1.2rem;
    line-height: 1.6;
    text-align: center;
}

.one-time-fullscreen-footer {
    padding: 1rem;
    text-align: center;
    background: rgba(0, 0, 0, 0.5);
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
}

.one-time-fullscreen-footer span {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.85rem;
    transition: color 0.2s ease;
}

/* Action Icons */
.action-icon {
    width: 20px;
    height: 20px;
}

.send-icon {
    width: 20px;
    height: 20px;
}

/* One-Time Toggle Button */
#oneTimeBtn.active {
    background: #667eea !important;
    color: white;
}

#oneTimeBtn.active i {
    color: white;
}

/* ========================================
   GROUP SETTINGS MODAL STYLES
   ======================================== */

.group-settings-container {
    background: white;
    border-radius: 16px;
    width: 90%;
    max-width: 480px;
    max-height: 85vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    animation: slideUp 0.3s ease;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.group-settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid #e2e8f0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.group-settings-header h3 {
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 0;
}

.group-settings-header i {
    width: 20px;
    height: 20px;
}

.group-settings-header .modal-close-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.group-settings-header .modal-close-btn:hover {
    background: rgba(255,255,255,0.3);
}

.group-settings-body {
    overflow-y: auto;
    flex: 1;
    padding: 0;
}

/* Group Info Section */
.group-info-section {
    text-align: center;
    padding: 24px 20px;
    background: linear-gradient(to bottom, #f8fafc, white);
    border-bottom: 1px solid #e2e8f0;
}

.group-avatar-large {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 0 auto 16px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.group-icon-large {
    width: 40px;
    height: 40px;
    color: white;
}

.group-name-large {
    font-size: 1.4rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 8px;
}

.group-meta {
    font-size: 0.85rem;
    color: #64748b;
    margin-bottom: 12px;
}

.group-meta .separator {
    margin: 0 8px;
}

.group-description {
    font-size: 0.9rem;
    color: #475569;
    line-height: 1.5;
    max-width: 350px;
    margin: 0 auto;
}

.group-description em {
    color: #94a3b8;
}

/* Quick Actions */
.group-actions-section {
    display: flex;
    gap: 12px;
    padding: 16px 20px;
    border-bottom: 1px solid #e2e8f0;
}

.group-action-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 16px;
    background: #f1f5f9;
    border: none;
    border-radius: 10px;
    color: #475569;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.group-action-btn:hover {
    background: #e2e8f0;
    color: #1e293b;
}

.group-action-btn i {
    width: 18px;
    height: 18px;
}

/* Edit Group Form */
.edit-group-form {
    padding: 16px 20px;
    background: #f8fafc;
    border-bottom: 1px solid #e2e8f0;
}

.edit-group-form h4 {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 16px 0;
}

.edit-group-form .form-group {
    margin-bottom: 14px;
}

.edit-group-form label {
    display: block;
    font-size: 0.85rem;
    font-weight: 500;
    color: #475569;
    margin-bottom: 6px;
}

.edit-group-form input[type="text"],
.edit-group-form input[type="number"],
.edit-group-form textarea {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 8px;
    font-size: 0.9rem;
    transition: border-color 0.2s, box-shadow 0.2s;
    box-sizing: border-box;
}

.edit-group-form input:focus,
.edit-group-form textarea:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.checkbox-group {
    display: flex;
    align-items: flex-start;
}

.checkbox-group label {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    cursor: pointer;
}

.checkbox-group input[type="checkbox"] {
    width: 18px;
    height: 18px;
    margin-top: 2px;
    accent-color: #667eea;
}

.checkbox-group span {
    font-size: 0.85rem;
    color: #475569;
}

.form-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 16px;
}

/* Members Section */
.group-members-section {
    padding: 16px 20px;
}

.group-members-section .section-header {
    margin-bottom: 12px;
}

.group-members-section h4 {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1e293b;
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 0;
}

.group-members-section h4 i {
    width: 16px;
    height: 16px;
    color: #64748b;
}

.members-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 280px;
    overflow-y: auto;
}

.loading-members {
    text-align: center;
    padding: 24px;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.loading-members i {
    width: 18px;
    height: 18px;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.spin {
    animation: spin 1s linear infinite;
}

.member-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: #f8fafc;
    border-radius: 10px;
    transition: background 0.2s;
}

.member-item:hover {
    background: #f1f5f9;
}

.member-avatar {
    width: 42px;
    height: 42px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.member-avatar-fallback {
    width: 42px;
    height: 42px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: 600;
    flex-shrink: 0;
}

.member-info {
    flex: 1;
    min-width: 0;
}

.member-name {
    font-size: 0.9rem;
    font-weight: 600;
    color: #1e293b;
    display: flex;
    align-items: center;
    gap: 6px;
}

.admin-badge {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-size: 0.65rem;
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: 600;
    text-transform: uppercase;
}

.member-status {
    font-size: 0.8rem;
    color: #64748b;
    display: flex;
    align-items: center;
    gap: 4px;
}

.online-dot {
    width: 8px;
    height: 8px;
    background: #10b981;
    border-radius: 50%;
}

.member-actions {
    flex-shrink: 0;
}

.remove-member-btn {
    background: #fee2e2;
    border: none;
    color: #dc2626;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.remove-member-btn:hover {
    background: #fecaca;
    transform: scale(1.1);
}

.remove-member-btn i {
    width: 16px;
    height: 16px;
}

/* Danger Zone */
.group-danger-section {
    padding: 16px 20px;
    border-top: 1px solid #e2e8f0;
    background: #fef2f2;
}

.leave-group-btn {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    font-size: 0.95rem;
    font-weight: 500;
}

.leave-group-btn i {
    width: 18px;
    height: 18px;
}

/* Confirm Modal */
.confirm-modal-container {
    background: white;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    width: 90%;
    max-width: 360px;
    animation: slideUp 0.3s ease;
}

.confirm-modal-icon {
    font-size: 3rem;
    margin-bottom: 16px;
}

.confirm-modal-container h3 {
    font-size: 1.2rem;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 8px 0;
}

.confirm-modal-container p {
    font-size: 0.9rem;
    color: #64748b;
    margin: 0 0 20px 0;
    line-height: 1.5;
}

.admin-warning {
    background: #fef3c7;
    color: #92400e;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    margin-bottom: 16px !important;
}

.confirm-modal-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.confirm-modal-actions .btn {
    flex: 1;
    max-width: 140px;
}

/* Mobile Adjustments */
@media (max-width: 480px) {
    .group-settings-container {
        width: 95%;
        max-height: 90vh;
    }
    
    .group-actions-section {
        flex-direction: column;
    }
    
    .members-list {
        max-height: 200px;
    }
}

/* ========================================
   INSTAGRAM-STYLE REACTION PICKER
   ======================================== */

.reaction-picker-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease;
    padding: 1rem;
}

.reaction-picker-container {
    background: white;
    border-radius: 2rem;
    padding: 0.5rem 0.75rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    animation: scaleIn 0.2s ease;
    max-width: calc(100vw - 2rem);
    overflow-x: auto;
}

@keyframes scaleIn {
    from {
        opacity: 0;
        transform: scale(0.8);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.reaction-picker-emojis {
    display: flex;
    gap: 0.15rem;
    flex-wrap: nowrap;
}

.reaction-emoji {
    font-size: 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.4rem;
    border-radius: 50%;
    transition: all 0.2s ease;
    line-height: 1;
    flex-shrink: 0;
}

.reaction-emoji:hover {
    background: #f3f4f6;
    transform: scale(1.2);
}

.reaction-emoji:active {
    transform: scale(1.3);
}

/* Reaction display on messages */
.reaction {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: #f3f4f6;
    border-radius: 1rem;
    padding: 0.15rem 0.4rem;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid #e5e7eb;
}

.reaction:hover {
    background: #e5e7eb;
    transform: scale(1.1);
}

/* Toast Animations */
@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(100%);
    }
}

/* ========================================
   P2P FILE SHARING STYLES
   ======================================== */

.p2p-modal-container {
    background: white;
    border-radius: 16px;
    width: 90%;
    max-width: 480px;
    max-height: 85vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    animation: slideUp 0.3s ease;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
}

.p2p-modal-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 20px;
    border-bottom: 1px solid #e2e8f0;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
}

.p2p-modal-header h3 {
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 0;
    flex: 1;
}

.p2p-modal-header h3 i {
    width: 20px;
    height: 20px;
}

.p2p-badge {
    background: rgba(255,255,255,0.2);
    padding: 4px 10px;
    border-radius: 20px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
}

.p2p-modal-header .modal-close-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.p2p-modal-header .modal-close-btn:hover {
    background: rgba(255,255,255,0.3);
}

.p2p-modal-body {
    padding: 20px;
    flex: 1;
    overflow-y: auto;
}

.p2p-step {
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.p2p-info-banner {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px;
    background: #ecfdf5;
    border: 1px solid #a7f3d0;
    border-radius: 10px;
    margin-bottom: 20px;
}

.p2p-info-banner i {
    width: 20px;
    height: 20px;
    color: #059669;
    flex-shrink: 0;
    margin-top: 2px;
}

.p2p-info-banner p {
    font-size: 0.85rem;
    color: #065f46;
    margin: 0;
    line-height: 1.5;
}

.p2p-file-select {
    border: 2px dashed #cbd5e1;
    border-radius: 12px;
    padding: 40px 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
}

.p2p-file-select:hover {
    border-color: #10b981;
    background: #f0fdf4;
}

.p2p-upload-icon {
    width: 48px;
    height: 48px;
    color: #94a3b8;
    margin-bottom: 12px;
}

.p2p-file-select p {
    font-size: 1rem;
    color: #475569;
    margin: 0 0 6px 0;
    font-weight: 500;
}

.p2p-hint {
    font-size: 0.8rem;
    color: #94a3b8;
}

.p2p-selected-file {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    margin-top: 16px;
}

.p2p-file-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.p2p-file-icon {
    width: 36px;
    height: 36px;
    color: #10b981;
}

.p2p-file-details {
    display: flex;
    flex-direction: column;
}

.p2p-file-name {
    font-size: 0.9rem;
    font-weight: 600;
    color: #1e293b;
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.p2p-file-size {
    font-size: 0.8rem;
    color: #64748b;
}

.p2p-remove-file {
    background: #fee2e2;
    border: none;
    color: #dc2626;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.p2p-remove-file:hover {
    background: #fecaca;
}

.p2p-remove-file i {
    width: 16px;
    height: 16px;
}

/* Recipient List */
.p2p-step h4 {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 12px 0;
}

.p2p-step2-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.p2p-step2-header h4 {
    margin: 0;
}

.p2p-refresh-btn {
    background: #f1f5f9;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 6px 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.75rem;
    color: #64748b;
    transition: all 0.2s;
}

.p2p-refresh-btn:hover {
    background: #e2e8f0;
    color: #475569;
}

.p2p-refresh-btn i {
    width: 14px;
    height: 14px;
}

.p2p-step2-note {
    font-size: 0.7rem;
    color: #94a3b8;
    margin: 0 0 10px 0;
    text-align: center;
}

.p2p-recipient-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 300px;
    overflow-y: auto;
}

.p2p-recipient-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: #f8fafc;
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.p2p-recipient-item:hover {
    background: #f0fdf4;
    border-color: #a7f3d0;
}

.p2p-recipient-item.selected {
    background: #ecfdf5;
    border-color: #10b981;
}

.p2p-recipient-item.offline {
    opacity: 0.6;
}

.p2p-recipient-avatar {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    object-fit: cover;
}

.p2p-recipient-avatar-fallback {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: 600;
}

.p2p-recipient-info {
    flex: 1;
}

.p2p-recipient-name {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1e293b;
}

.p2p-recipient-status {
    font-size: 0.8rem;
    color: #64748b;
    display: flex;
    align-items: center;
    gap: 6px;
}

.p2p-recipient-status .online-dot {
    width: 8px;
    height: 8px;
    background: #10b981;
    border-radius: 50%;
}

.p2p-offline-warning {
    font-size: 0.75rem;
    color: #f59e0b;
    margin-top: 4px;
}

/* Transfer Status */
.p2p-transfer-status {
    text-align: center;
    padding: 20px 0;
}

.p2p-status-icon {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto 16px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.p2p-status-icon.connecting {
    background: #fef3c7;
    animation: pulse 1.5s infinite;
}

.p2p-status-icon.connecting i {
    width: 36px;
    height: 36px;
    color: #f59e0b;
}

.p2p-status-icon.transferring {
    background: #dbeafe;
}

.p2p-status-icon.transferring i {
    width: 36px;
    height: 36px;
    color: #3b82f6;
    animation: spin 1s linear infinite;
}

.p2p-status-icon.complete {
    background: #dcfce7;
}

.p2p-status-icon.complete i {
    width: 36px;
    height: 36px;
    color: #10b981;
}

.p2p-status-icon.error {
    background: #fee2e2;
}

.p2p-status-icon.error i {
    width: 36px;
    height: 36px;
    color: #dc2626;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
}

.p2p-transfer-status h4 {
    font-size: 1.1rem;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 6px 0;
}

.p2p-transfer-status p {
    font-size: 0.85rem;
    color: #64748b;
    margin: 0;
}

/* Progress Bar */
.p2p-progress-container {
    margin: 20px 0;
}

.p2p-progress-bar {
    height: 8px;
    background: #e2e8f0;
    border-radius: 4px;
    overflow: hidden;
}

.p2p-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #10b981 0%, #059669 100%);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.p2p-progress-info {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 0.85rem;
    color: #64748b;
}

/* Transfer Details */
.p2p-transfer-details {
    background: #f8fafc;
    border-radius: 10px;
    padding: 14px;
}

.p2p-detail-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    font-size: 0.85rem;
}

.p2p-detail-row span:first-child {
    color: #64748b;
}

.p2p-detail-row span:last-child {
    color: #1e293b;
    font-weight: 500;
}

/* Modal Footer */
.p2p-modal-footer {
    display: flex;
    gap: 10px;
    padding: 16px 20px;
    border-top: 1px solid #e2e8f0;
    background: #f8fafc;
}

.p2p-modal-footer .btn {
    flex: 1;
}

#p2pNextBtn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

#p2pNextBtn i {
    width: 16px;
    height: 16px;
}

/* Incoming File Modal */
.p2p-incoming-container {
    background: white;
    border-radius: 16px;
    width: 90%;
    max-width: 380px;
    overflow: hidden;
    animation: bounceIn 0.4s ease;
}

@keyframes bounceIn {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); opacity: 1; }
}

.p2p-incoming-header {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
    padding: 24px;
    text-align: center;
}

.p2p-incoming-icon {
    width: 48px;
    height: 48px;
    margin-bottom: 12px;
}

.p2p-incoming-header h3 {
    margin: 0;
    font-size: 1.2rem;
}

.p2p-incoming-body {
    padding: 24px;
    text-align: center;
}

.p2p-incoming-sender {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 12px;
}

.p2p-sender-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.p2p-incoming-body > p {
    color: #64748b;
    margin: 0 0 16px 0;
}

.p2p-incoming-file {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    background: #f8fafc;
    padding: 16px;
    border-radius: 10px;
}

.p2p-incoming-file i {
    width: 32px;
    height: 32px;
    color: #3b82f6;
}

.p2p-incoming-file-info {
    text-align: left;
}

.p2p-incoming-file-name {
    display: block;
    font-weight: 600;
    color: #1e293b;
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.p2p-incoming-file-size {
    font-size: 0.8rem;
    color: #64748b;
}

.p2p-incoming-actions {
    display: flex;
    gap: 10px;
    padding: 16px 24px 24px;
}

.p2p-incoming-actions .btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.p2p-incoming-actions .btn i {
    width: 16px;
    height: 16px;
}

/* Receiving Modal */
.p2p-receiving-container {
    background: white;
    border-radius: 16px;
    width: 90%;
    max-width: 400px;
    overflow: hidden;
    animation: slideUp 0.3s ease;
}

.p2p-receiving-header {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
    padding: 16px 20px;
}

.p2p-receiving-header h3 {
    margin: 0;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.p2p-receiving-header h3 i {
    width: 20px;
    height: 20px;
}

.p2p-receiving-body {
    padding: 24px;
}

.p2p-receiving-file-info {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
}

.p2p-receiving-file-icon {
    width: 32px;
    height: 32px;
    color: #3b82f6;
}

.p2p-receiving-body #p2pReceivingFileName {
    font-weight: 600;
    color: #1e293b;
}

.p2p-receiving-body #p2pReceivingStatus {
    text-align: center;
    color: #64748b;
    font-size: 0.9rem;
    margin: 16px 0 0 0;
}

.p2p-receiving-actions {
    padding: 16px 24px 24px;
    text-align: center;
}

</style>

<script>
    //REPLY REACT DELETE RRD
    function toggleMessageMenu(button) {
        event.stopPropagation();
        const container = button.closest('.message-menu-container');
        const menu = container.querySelector('.message-menu');
        const isVisible = menu.classList.contains('show');
        
        // Close all menus first
        closeAllMenus();
        
        // Toggle current menu
        if (!isVisible) {
            menu.classList.add('show');
            container.classList.add('active');
            
            // Position the menu using fixed positioning
            const buttonRect = button.getBoundingClientRect();
            const menuRect = menu.getBoundingClientRect();
            const menuWidth = menuRect.width || 200;
            const menuHeight = menuRect.height || 50;
            const viewportWidth = window.innerWidth;
            
            // Check if this is an own message (right-aligned)
            const isOwnMessage = button.closest('.message--own') !== null;
            
            // Calculate position - place above the button
            let top = buttonRect.top - menuHeight - 8;
            let left;
            
            if (isOwnMessage) {
                // For own messages, align menu to the right edge of button
                left = buttonRect.right - menuWidth;
            } else {
                // For received messages, align menu to the left edge of button
                left = buttonRect.left;
            }
            
            // If menu would go above viewport, place it below instead
            if (top < 10) {
                top = buttonRect.bottom + 8;
            }
            
            // Keep menu within horizontal bounds
            if (left < 10) {
                left = 10;
            } else if (left + menuWidth > viewportWidth - 10) {
                left = viewportWidth - menuWidth - 10;
            }
            
            // Apply position
            menu.style.top = top + 'px';
            menu.style.left = left + 'px';
        }
    }
    
    // Close menus when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.message-menu-container')) {
            closeAllMenus();
        }
    });
    
    // Close menus when scrolling
    document.querySelector('.messages-container-enhanced')?.addEventListener('scroll', function() {
        closeAllMenus();
    });
    
    function closeAllMenus() {
        document.querySelectorAll('.message-menu').forEach(m => {
            m.classList.remove('show');
            m.style.top = '';
            m.style.left = '';
        });
        document.querySelectorAll('.message-menu-container').forEach(c => {
            c.classList.remove('active');
        });
        document.querySelectorAll('.delete-submenu').forEach(s => {
            s.classList.remove('show');
        });
    }

// Scroll to a specific message and highlight it
function scrollToMessage(messageId) {
    const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageEl) {
        // Scroll to the message
        messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Add highlight effect
        messageEl.classList.add('message-highlight');
        
        // Remove highlight after animation completes
        setTimeout(() => {
            messageEl.classList.remove('message-highlight');
        }, 2000);
    } else {
        // Message might not be loaded (older messages)
        showNotification('Original message not found in current view', 'info');
    }
}

function replyToMessage(id) {
    const msgEl = document.querySelector(`[data-message-id="${id}"] .message-text`);
    const preview = msgEl ? msgEl.textContent.slice(0, 60) : 'Message';
    const replyBox = document.getElementById('reply-preview');
    const replyText = document.getElementById('reply-text');
    
    if (replyBox && replyText) {
        replyText.innerHTML = `<strong>Replying to:</strong> ${preview}...`;
        replyBox.style.display = 'block';
        replyBox.dataset.replyTo = id;
        document.getElementById('messageInput').focus();
    }
}

function cancelReply() {
    const replyBox = document.getElementById('reply-preview');
    if (replyBox) {
        replyBox.style.display = 'none';
        replyBox.dataset.replyTo = '';
    }
}

function reactToMessage(messageId) {
    // Store the message ID for the reaction
    window.currentReactionMessageId = messageId;
    
    // Show emoji picker
    const emojiPicker = document.getElementById('emojiPicker');
    if (emojiPicker) {
        emojiPicker.style.display = 'block';
        emojiPicker.classList.add('reaction-mode');
        
        // Position near the message (optional)
        const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageEl) {
            const rect = messageEl.getBoundingClientRect();
            emojiPicker.style.position = 'fixed';
            emojiPicker.style.left = rect.right + 10 + 'px';
            emojiPicker.style.top = rect.top + 'px';
        }
    }
}

function deleteMessage(id) {
    alert("Delete logic for message ID " + id + " (send API request)");
}

//DELETE#%*
function toggleDeleteSubmenu(triggerElement) {
    event.preventDefault();
    event.stopPropagation();
    
    // Get the submenu (sibling element in the menu)
    const menu = triggerElement.closest('.message-menu');
    const submenu = menu ? menu.querySelector('.delete-submenu') : null;
    if (!submenu) {
        console.error('Delete submenu not found');
        return;
    }
    
    // Close all other submenus first
    document.querySelectorAll('.delete-submenu').forEach(s => {
        if (s !== submenu) {
            s.classList.remove('show');
        }
    });

    // Toggle this submenu
    submenu.classList.toggle('show');
}

// ==================== DELETE MODAL FUNCTIONS ====================
let currentDeleteMessageId = null;
let currentDeleteIsOwn = false;

function showDeleteModal(messageId, isOwn) {
    currentDeleteMessageId = messageId;
    currentDeleteIsOwn = isOwn;
    
    const modal = document.getElementById('deleteModal');
    const deleteForEveryoneBtn = document.getElementById('deleteForEveryoneBtn');
    
    // Show/hide "Delete for everyone" based on ownership
    if (deleteForEveryoneBtn) {
        deleteForEveryoneBtn.style.display = isOwn ? 'flex' : 'none';
    }
    
    modal.classList.add('show');
}

function closeDeleteModal() {
    const modal = document.getElementById('deleteModal');
    modal.classList.remove('show');
    currentDeleteMessageId = null;
    currentDeleteIsOwn = false;
}

function confirmDeleteForMe() {
    if (!currentDeleteMessageId) return;
    
    fetch(`/delete-message-for-me/${currentDeleteMessageId}/`, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') },
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            const msgEl = document.querySelector(`[data-message-id="${currentDeleteMessageId}"]`);
            if (msgEl) msgEl.remove();
            closeDeleteModal();
        } else {
            alert(data.message || "Error deleting message");
        }
    })
    .catch(err => {
        console.error(err);
        alert("Failed to delete message");
    });
}

function confirmDeleteForEveryone() {
    if (!currentDeleteMessageId) return;
    
    fetch(`/delete-message-for-everyone/${currentDeleteMessageId}/`, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') },
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            const msgEl = document.querySelector(`[data-message-id="${currentDeleteMessageId}"]`);
            if (msgEl) msgEl.remove();
            closeDeleteModal();
        } else {
            alert(data.message || "Error deleting message");
        }
    })
    .catch(err => {
        console.error(err);
        alert("Failed to delete message");
    });
}

// Close modal when clicking outside
document.getElementById('deleteModal')?.addEventListener('click', function(e) {
    if (e.target === this) {
        closeDeleteModal();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        closeDeleteModal();
    }
});

// ==================== STARRED MESSAGES ====================

function toggleStarMessage(messageId) {
    console.log('Starring message:', messageId);
    fetch(`/api/star-message/${messageId}/`, {
        method: 'POST',
        headers: { 
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json'
        },
    })
    .then(res => {
        console.log('Response status:', res.status);
        return res.json();
    })
    .then(data => {
        console.log('Star response:', data);
        if (data.success) {
            // Update star button appearance
            const starBtn = document.querySelector(`.star-btn[data-message-id="${messageId}"]`);
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            
            if (data.is_starred) {
                if (starBtn) starBtn.classList.add('starred');
                // Add star indicator to message
                if (messageEl && !messageEl.querySelector('.starred-indicator')) {
                    const timeEl = messageEl.querySelector('.message-time');
                    if (timeEl) {
                        const starIndicator = document.createElement('span');
                        starIndicator.className = 'starred-indicator';
                        starIndicator.innerHTML = '‚≠ê';
                        timeEl.insertBefore(starIndicator, timeEl.firstChild);
                    }
                }
                showToast('Message starred ‚≠ê');
            } else {
                if (starBtn) starBtn.classList.remove('starred');
                // Remove star indicator
                if (messageEl) {
                    const indicator = messageEl.querySelector('.starred-indicator');
                    if (indicator) indicator.remove();
                }
                showToast('Message unstarred');
            }
        } else {
            showToast(data.error || 'Failed to star message', 'error');
        }
    })
    .catch(err => {
        console.error('Error starring message:', err);
        showToast('Failed to star message', 'error');
    });
}

// Simple toast notification
function showToast(message, type = 'success') {
    const existing = document.querySelector('.toast-notification');
    if (existing) existing.remove();
    
    const toast = document.createElement('div');
    toast.className = `toast-notification ${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.add('show'), 10);
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 2500);
}

// ==================== TYPING INDICATORS ====================

let typingTimeout = null;
let isCurrentlyTyping = false;
const chatId = {{ chat.id }};

function sendTypingStatus(isTyping) {
    if (isCurrentlyTyping === isTyping) return;
    isCurrentlyTyping = isTyping;
    
    fetch(`/api/chat/${chatId}/typing/`, {
        method: 'POST',
        headers: { 
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: `is_typing=${isTyping}`
    }).catch(err => console.error('Typing status error:', err));
}

function handleTypingInput() {
    sendTypingStatus(true);
    
    // Clear existing timeout
    if (typingTimeout) clearTimeout(typingTimeout);
    
    // Stop typing after 2 seconds of inactivity
    typingTimeout = setTimeout(() => {
        sendTypingStatus(false);
    }, 2000);
}

// Attach to message input
document.addEventListener('DOMContentLoaded', function() {
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.addEventListener('input', handleTypingInput);
        messageInput.addEventListener('blur', () => sendTypingStatus(false));
    }
});

// Poll for typing status
let typingPollInterval = null;

function startTypingPolling() {
    typingPollInterval = setInterval(() => {
        fetch(`/api/chat/${chatId}/typing-status/`)
        .then(res => res.json())
        .then(data => {
            const indicator = document.getElementById('typingIndicator');
            if (data.typing_users && data.typing_users.length > 0) {
                const names = data.typing_users.map(u => u.name).join(', ');
                const typingText = indicator.querySelector('.typing-text');
                if (typingText) {
                    typingText.textContent = data.typing_users.length === 1 
                        ? `${names} is typing...` 
                        : `${names} are typing...`;
                }
                indicator.style.display = 'flex';
            } else {
                indicator.style.display = 'none';
            }
        })
        .catch(err => console.error('Error polling typing status:', err));
    }, 1500);
}

// Start polling when page loads
document.addEventListener('DOMContentLoaded', startTypingPolling);

// ==================== READ RECEIPTS ====================

function markMessagesAsRead() {
    fetch(`/api/chat/${chatId}/mark-read/`, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') },
    })
    .catch(err => console.error('Error marking messages read:', err));
}

function updateReadReceipts() {
    fetch(`/api/chat/${chatId}/read-status/`)
    .then(res => res.json())
    .then(data => {
        if (data.success && data.read_status) {
            Object.keys(data.read_status).forEach(msgId => {
                const receipt = document.querySelector(`.read-receipt[data-message-id="${msgId}"]`);
                if (receipt) {
                    const status = data.read_status[msgId];
                    receipt.classList.remove('sent', 'delivered', 'read');
                    
                    if (status.status === 'read') {
                        receipt.innerHTML = '‚úì‚úì';
                        receipt.classList.add('read');
                        receipt.title = 'Read';
                    } else if (status.status === 'delivered') {
                        receipt.innerHTML = '‚úì‚úì';
                        receipt.classList.add('delivered');
                        receipt.title = 'Delivered';
                    } else {
                        receipt.innerHTML = '‚úì';
                        receipt.title = 'Sent';
                    }
                }
            });
        }
    })
    .catch(err => console.error('Error updating read receipts:', err));
}

// Mark messages as read when chat is focused
document.addEventListener('DOMContentLoaded', function() {
    markMessagesAsRead();
    updateReadReceipts();
    
    // Update read receipts periodically
    setInterval(updateReadReceipts, 5000);
});

// Mark as read when window gains focus
window.addEventListener('focus', markMessagesAsRead);

// helper to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// ==================== MESSAGE EDITING ====================
let currentEditingMessageId = null;

function editMessage(messageId) {
    // Get the message element and its content
    const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageEl) return;
    
    const messageText = messageEl.querySelector('.message-text');
    if (!messageText) {
        alert('Only text messages can be edited');
        return;
    }
    
    // Get the text content (strip HTML)
    const textContent = messageText.innerText.trim();
    
    currentEditingMessageId = messageId;
    document.getElementById('editMessageText').value = textContent;
    document.getElementById('editTimeRemaining').textContent = 'You can edit messages within 15 minutes of sending.';
    document.getElementById('editMessageModal').classList.add('show');
}

function closeEditModal() {
    currentEditingMessageId = null;
    document.getElementById('editMessageModal').classList.remove('show');
    document.getElementById('editMessageText').value = '';
}

function saveEditedMessage() {
    if (!currentEditingMessageId) return;
    
    const newContent = document.getElementById('editMessageText').value.trim();
    if (!newContent) {
        alert('Message cannot be empty');
        return;
    }
    
    fetch(`/api/edit-message/${currentEditingMessageId}/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ content: newContent })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the message in the UI
            const messageEl = document.querySelector(`[data-message-id="${currentEditingMessageId}"]`);
            if (messageEl) {
                const messageText = messageEl.querySelector('.message-text');
                if (messageText) {
                    messageText.innerHTML = newContent.replace(/\n/g, '<br>');
                }
                
                // Add edited indicator if not present
                const messageTime = messageEl.querySelector('.message-time');
                if (messageTime && !messageTime.querySelector('.edited-indicator')) {
                    const editedSpan = document.createElement('span');
                    editedSpan.className = 'edited-indicator';
                    editedSpan.textContent = ' (edited)';
                    editedSpan.title = 'Edited just now';
                    messageTime.appendChild(editedSpan);
                }
                
                messageEl.setAttribute('data-is-edited', 'true');
            }
            closeEditModal();
        } else {
            alert(data.error || 'Failed to edit message');
        }
    })
    .catch(err => {
        console.error(err);
        alert('Failed to edit message');
    });
}

// Close edit modal when clicking outside
document.getElementById('editMessageModal')?.addEventListener('click', function(e) {
    if (e.target === this) {
        closeEditModal();
    }
});

// ==================== MESSAGE PINNING ====================
function togglePinMessage(messageId) {
    fetch(`/api/pin-message/${messageId}/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageEl) {
                if (data.pinned) {
                    messageEl.classList.add('message--pinned');
                    messageEl.setAttribute('data-is-pinned', 'true');
                    
                    // Add pinned indicator if not present
                    if (!messageEl.querySelector('.pinned-indicator')) {
                        const pinnedDiv = document.createElement('div');
                        pinnedDiv.className = 'pinned-indicator';
                        pinnedDiv.innerHTML = '<i data-lucide="pin" class="pin-icon"></i> Pinned';
                        messageEl.insertBefore(pinnedDiv, messageEl.firstChild);
                        lucide.createIcons();
                    }
                } else {
                    messageEl.classList.remove('message--pinned');
                    messageEl.setAttribute('data-is-pinned', 'false');
                    
                    // Remove pinned indicator
                    const pinnedIndicator = messageEl.querySelector('.pinned-indicator');
                    if (pinnedIndicator) pinnedIndicator.remove();
                }
            }
            
            // Reload pinned messages section
            loadPinnedMessages();
            
            // Update the menu icon dynamically
            const pinOption = messageEl?.querySelector('.pin-action');
            if (pinOption) {
                pinOption.title = data.pinned ? 'Unpin' : 'Pin';
                pinOption.dataset.pinned = data.pinned ? 'true' : 'false';
                pinOption.innerHTML = data.pinned ? 'üìç' : 'üìå';
            }
        } else {
            alert(data.error || 'Failed to toggle pin');
        }
    })
    .catch(err => {
        console.error(err);
        alert('Failed to toggle pin');
    });
}

function loadPinnedMessages() {
    const chatId = {{ chat.id }};
    
    fetch(`/api/chat/${chatId}/pinned-messages/`)
    .then(response => response.json())
    .then(data => {
        const section = document.getElementById('pinnedMessagesSection');
        const list = document.getElementById('pinnedMessagesList');
        
        if (data.success && data.pinned_messages && data.pinned_messages.length > 0) {
            section.style.display = 'block';
            list.innerHTML = data.pinned_messages.map(msg => {
                const senderName = msg.sender?.full_name || msg.sender?.username || 'Unknown';
                const content = msg.content || (msg.has_media ? 'üìé Media' : 'Message');
                return `
                    <div class="pinned-message-item" onclick="scrollToMessage(${msg.id})">
                        <div class="pinned-message-icon">
                            <i data-lucide="pin"></i>
                        </div>
                        <div class="pinned-message-info">
                            <div class="pinned-message-sender">${escapeHtml(senderName)}</div>
                            <div class="pinned-message-content">${escapeHtml(content)}</div>
                        </div>
                        <div class="pinned-message-arrow">
                            <i data-lucide="chevron-right"></i>
                        </div>
                    </div>
                `;
            }).join('');
            // Reinitialize Lucide icons for the new elements
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        } else {
            section.style.display = 'none';
            list.innerHTML = '';
        }
    })
    .catch(err => {
        console.error('Error loading pinned messages:', err);
        document.getElementById('pinnedMessagesSection').style.display = 'none';
    });
}

function scrollToMessage(messageId) {
    const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageEl) {
        messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        messageEl.classList.add('highlight-message');
        setTimeout(() => messageEl.classList.remove('highlight-message'), 2000);
    }
}

function escapeHtml(text) {
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
    return text.replace(/[&<>"']/g, m => map[m]);
}

// Load pinned messages on page load
document.addEventListener('DOMContentLoaded', function() {
    loadPinnedMessages();
});

// ==================== REACTION PICKER (Instagram-style) ====================
let currentReactionMessageId = null;

function openReactionPicker(messageId) {
    currentReactionMessageId = messageId;
    const picker = document.getElementById('reactionPicker');
    picker.style.display = 'flex';
    document.body.style.overflow = 'hidden';
}

function closeReactionPicker() {
    const picker = document.getElementById('reactionPicker');
    picker.style.display = 'none';
    document.body.style.overflow = '';
    currentReactionMessageId = null;
}

function sendReaction(emoji) {
    if (!currentReactionMessageId) return;
    
    const messageId = currentReactionMessageId;
    closeReactionPicker();
    
    fetch(`/api/react-message/${messageId}/`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": getCookie("csrftoken"),
        },
        body: JSON.stringify({ emoji }),
    })
    .then(res => res.json())
    .then(data => {
        const container = document.getElementById(`reactions-${messageId}`);
        if (!container) return;
        
        if (data.status === "added") {
            // Check if reaction already exists
            let existingReaction = null;
            container.querySelectorAll('.reaction').forEach(r => {
                if (r.textContent.includes(data.emoji)) existingReaction = r;
            });
            
            if (!existingReaction) {
                const span = document.createElement("span");
                span.className = "reaction";
                span.textContent = data.emoji;
                span.onclick = () => sendReaction(data.emoji);
                container.appendChild(span);
            }
            showToast(`Reacted with ${data.emoji}`, 'success');
        } else if (data.status === "removed") {
            container.querySelectorAll(".reaction").forEach(r => {
                if (r.textContent === data.emoji) r.remove();
            });
            showToast('Reaction removed', 'info');
        }
    })
    .catch(err => {
        console.error(err);
        showToast('Failed to add reaction', 'error');
    });
}

// Enhanced Chat Application with Mobile Support and Performance Optimization
class EnhancedChatApp {
    constructor() {
        this.chatId = document.getElementById('chatId')?.value;
        this.messageInput = document.getElementById('messageInput');
        this.messagesContainer = document.getElementById('messages-container');
        this.messageForm = document.getElementById('messageForm');
        this.sendBtn = document.getElementById('sendBtn');
        this.mediaInput = document.getElementById('mediaInput');
        this.sidebar = document.getElementById('sidebar');
        this.sidebarOverlay = document.getElementById('sidebarOverlay');
        console.log('One-time button in constructor:', document.getElementById('oneTimeBtn'));
        this.lastMessageTime = null;
        this.lastMessageId = null;
        this.pollInterval = null;
        this.isPolling = false;
        this.selectedMedia = null;
        this.isMobile = this.checkMobile();
        this.resizeObserver = null;
        this.typingTimeout = null;
        this.isTyping = false;
        this.oneTimeEnabled = false;
        this.typingPollInterval = null;
        this.lastTypingTime = 0;
        this.onlineStatusInterval = null;
        this.heartbeatInterval = null;
        this.messagePollingSpeed = 1500; // 1.5 seconds for responsive updates
        this.onlinePollingSpeed = 5000; // 5 seconds for online status
        this.heartbeatSpeed = 8000; // 8 seconds heartbeat

        if (this.chatId && this.messageInput && this.messagesContainer) {
            console.log('Chat app initialized successfully');
            this.init();
            this.initializeEmojis();
            this.initMobileHandlers();
        } else {
            console.error('Chat app initialization failed - missing elements');
            console.log('chatId:', this.chatId);
            console.log('messageInput:', this.messageInput);
            console.log('messagesContainer:', this.messagesContainer);
        }
    }

    checkMobile() {
        return window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    init() {
        this.bindEvents();
        this.autoScrollToBottom();
        this.startPolling();
        this.autoResizeTextarea();
        this.initResizeObserver();
        this.initLucideIcons();
        
        // Start online status polling for private chats
        this.startOnlineStatusPolling();
        
        // Start heartbeat to keep user marked as online
        this.startHeartbeat();

        // Get last message ID for efficient polling
        const messages = this.messagesContainer.querySelectorAll('.message[data-message-id]');
        if (messages.length > 0) {
            const lastMsg = messages[messages.length - 1];
            this.lastMessageId = lastMsg.dataset.messageId;
            this.lastMessageTime = new Date().toISOString();
        }

        // Handle window resize
        window.addEventListener('resize', this.debounce(() => {
            const wasMobile = this.isMobile;
            this.isMobile = this.checkMobile();
            
            // Close sidebar if switching to mobile
            if (this.isMobile && !wasMobile) {
                this.closeMobileSidebar();
            }
        }, 250));

        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.stopPolling();
                this.stopOnlineStatusPolling();
                this.stopHeartbeat();
            } else {
                this.startPolling();
                this.startOnlineStatusPolling();
                this.startHeartbeat();
                // Immediately check for new messages when tab becomes visible
                this.checkForNewMessages();
                this.checkParticipantOnlineStatus();
            }
        });
        
        // Also handle window focus/blur for better responsiveness
        window.addEventListener('focus', () => {
            this.checkForNewMessages();
            this.checkParticipantOnlineStatus();
        });
        
        // Handle mobile keyboard appearance
        if (this.isMobile && this.messageInput) {
            // Use visualViewport API for better keyboard detection
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    this.handleKeyboardChange();
                });
            }
            
            // Fallback: focus/blur events
            this.messageInput.addEventListener('focus', () => {
                setTimeout(() => {
                    this.scrollToBottomSmooth();
                }, 300);
            });
        }
    }
    
    handleKeyboardChange() {
        if (!window.visualViewport) return;
        
        const header = document.querySelector('.chat-header-enhanced');
        const inputContainer = document.querySelector('.message-input-container-enhanced');
        
        if (header && inputContainer) {
            const viewportHeight = window.visualViewport.height;
            const windowHeight = window.innerHeight;
            const keyboardHeight = windowHeight - viewportHeight;
            
            if (keyboardHeight > 100) {
                // Keyboard is open - adjust layout
                document.body.style.height = viewportHeight + 'px';
                inputContainer.style.paddingBottom = '0';
            } else {
                // Keyboard is closed - reset layout
                document.body.style.height = '';
                inputContainer.style.paddingBottom = '';
            }
        }
    }
    
    scrollToBottomSmooth() {
        if (this.messagesContainer) {
            this.messagesContainer.scrollTo({
                top: this.messagesContainer.scrollHeight,
                behavior: 'smooth'
            });
        }
    }
    
    // Heartbeat to keep current user marked as online
    startHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        
        // Send initial heartbeat
        this.sendHeartbeat();
        
        // Send heartbeat periodically
        this.heartbeatInterval = setInterval(() => {
            this.sendHeartbeat();
        }, this.heartbeatSpeed);
    }
    
    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }
    
    async sendHeartbeat() {
        try {
            await fetch('/api/user/heartbeat/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json'
                }
            });
        } catch (error) {
            // Silent fail for heartbeat
        }
    }
    
    // Online status polling for private chats
    startOnlineStatusPolling() {
        if (this.onlineStatusInterval) {
            clearInterval(this.onlineStatusInterval);
        }
        
        // Initial check
        this.checkParticipantOnlineStatus();
        
        // Poll every 5 seconds for responsive online/offline detection
        this.onlineStatusInterval = setInterval(() => {
            this.checkParticipantOnlineStatus();
        }, this.onlinePollingSpeed);
    }
    
    stopOnlineStatusPolling() {
        if (this.onlineStatusInterval) {
            clearInterval(this.onlineStatusInterval);
            this.onlineStatusInterval = null;
        }
    }
    
    async checkParticipantOnlineStatus() {
        if (!this.chatId || document.hidden) return;
        
        try {
            const response = await fetch(`/api/chat/${this.chatId}/participant-status/`, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': this.getCSRFToken()
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.participants) {
                    this.updateOnlineStatusUI(data.participants);
                }
            }
        } catch (error) {
            console.error('Error checking online status:', error);
        }
    }
    
    updateOnlineStatusUI(participants) {
        const statusHeader = document.querySelector('.chat-status-header');
        if (!statusHeader) return;
        
        // Find the status span (first one, not the typing indicator)
        const statusSpan = statusHeader.querySelector('.status-online, .status-offline');
        if (!statusSpan) return;
        
        // For private chats, there should be only one other participant
        if (participants.length === 1) {
            const participant = participants[0];
            const wasOnline = statusSpan.classList.contains('status-online');
            const isNowOnline = participant.is_online;
            
            // Only update if status changed to avoid flicker
            if (wasOnline !== isNowOnline || !statusSpan.dataset.initialized) {
                statusSpan.dataset.initialized = 'true';
                
                if (isNowOnline) {
                    statusSpan.className = 'status-online';
                    statusSpan.innerHTML = '<span class="online-dot-pulse"></span> Online';
                } else {
                    statusSpan.className = 'status-offline';
                    statusSpan.innerHTML = `<span class="offline-dot"></span> ${participant.last_seen_display}`;
                }
            } else if (!isNowOnline) {
                // Update last seen time even if still offline
                const currentText = statusSpan.textContent.trim();
                const newText = participant.last_seen_display;
                if (!currentText.includes(newText)) {
                    statusSpan.innerHTML = `<span class="offline-dot"></span> ${participant.last_seen_display}`;
                }
            }
        }
    }

    initResizeObserver() {
        if ('ResizeObserver' in window) {
            this.resizeObserver = new ResizeObserver(this.debounce(() => {
                this.autoScrollToBottom();
            }, 100));
            
            this.resizeObserver.observe(this.messagesContainer);
        }
    }

    initLucideIcons() {
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    initMobileHandlers() {
        let touchStartX = 0;
        let touchStartY = 0;
        let isSwiping = false;

        // Touch event handlers
        const handleTouchStart = (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            isSwiping = false;
        };

        const handleTouchMove = (e) => {
            if (!isSwiping) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;

                // Check if horizontal swipe
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    isSwiping = true;
                    
                    // Swipe right from left edge to open sidebar
                    if (touchStartX < 50 && deltaX > 100 && this.isMobile) {
                        this.openMobileSidebar();
                    }
                    // Swipe left to close sidebar
                    else if (deltaX < -100 && this.sidebar.classList.contains('show')) {
                        this.closeMobileSidebar();
                    }
                }
            }
        };

        // Prevent body scroll when sidebar is open on mobile
        const handleTouchMovePrevent = (e) => {
            if (this.isMobile && this.sidebar.classList.contains('show')) {
                if (!e.target.closest('.sidebar-enhanced-chat')) {
                    e.preventDefault();
                }
            }
        };

        document.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: true });
        document.addEventListener('touchmove', handleTouchMovePrevent, { passive: false });

        // Handle back button on mobile
        if (this.isMobile) {
            window.addEventListener('popstate', (e) => {
                if (this.sidebar.classList.contains('show')) {
                    e.preventDefault();
                    this.closeMobileSidebar();
                    history.pushState(null, null, window.location.href);
                }
            });
        }
    }

    bindEvents() {
        // Form submission
        this.messageForm?.addEventListener('submit', (e) => {
            e.preventDefault();
            this.sendMessage();
        });

        // Auto-resize textarea
        this.messageInput?.addEventListener('input', () => {
            this.autoResizeTextarea();
            this.handleTyping();
        });

        // Enter key handling
        this.messageInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });

        // Focus input initially
        setTimeout(() => {
            if (this.messageInput && !this.isMobile) {
                this.messageInput.focus();
            }
        }, 100);

        // Close emoji picker when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.emoji-picker') && !e.target.closest('.emoji-btn')) {
                const emojiPicker = document.getElementById('emojiPicker');
                if (emojiPicker) {
                    emojiPicker.style.display = 'none';
                }
            }
        });

        // Handle escape key to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close emoji picker
                const emojiPicker = document.getElementById('emojiPicker');
                if (emojiPicker && emojiPicker.style.display !== 'none') {
                    emojiPicker.style.display = 'none';
                    return;
                }
                
                // Close media viewer
                const mediaViewer = document.getElementById('mediaViewer');
                if (mediaViewer && mediaViewer.style.display !== 'none') {
                    closeMediaViewer();
                    return;
                }
                
                // Close invite modal
                const inviteModal = document.getElementById('inviteLinkModal');
                if (inviteModal && inviteModal.style.display !== 'none') {
                    closeInviteLinkModal();
                    return;
                }
                
                // Close mobile sidebar
                if (this.sidebar.classList.contains('show')) {
                    this.closeMobileSidebar();
                    return;
                }
            }
        });
    }

    openMobileSidebar() {
        if (this.isMobile) {
            this.sidebar.classList.add('show');
            this.sidebarOverlay.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Add to history stack for back button
            if (history.state?.sidebarOpen !== true) {
                history.pushState({ sidebarOpen: true }, null, window.location.href);
            }
        }
    }

    closeMobileSidebar() {
        this.sidebar.classList.remove('show');
        this.sidebarOverlay.classList.remove('show');
        document.body.style.overflow = '';
        
        // Remove from history stack
        if (history.state?.sidebarOpen === true) {
            history.back();
        }
    }

    autoResizeTextarea() {
        if (!this.messageInput) return;
        
        this.messageInput.style.height = 'auto';
        this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
    }

    async sendMessage() {
        const content = this.messageInput.value.trim();
        if (!content && !this.selectedMedia) return;

        // Disable send button and show loading state
        this.sendBtn.disabled = true;
        const sendIcon = this.sendBtn.querySelector('.send-icon-send');
        const loadingIcon = this.sendBtn.querySelector('.send-icon-loading');
        if (sendIcon && loadingIcon) {
            sendIcon.style.display = 'none';
            loadingIcon.style.display = 'inline-block';
        } else {
            console.error('Send icons not found');
        }

        try {
            // Prepare form data for media upload
            const formData = new FormData();
            formData.append('chat_id', this.chatId);
            formData.append('csrfmiddlewaretoken', this.getCSRFToken());
            if (content) formData.append('content', content);
            if (this.selectedMedia) formData.append('media', this.selectedMedia);
            if (this.oneTimeEnabled) formData.append('one_time', 'true');

            // Add temporary message to UI
            const tempMessage = this.addMessageToUI({
                content: content || 'üìé Media',
                sender_name: 'You',
                timestamp: new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' }),
                message_type: 'text',
                is_own: true,
                temporary: true,
                one_time: this.oneTimeEnabled,
                consumed: false
            });
            tempMessage.classList.add('message-sending');

            // Clear input and media
            this.messageInput.value = '';
            this.selectedMedia = null;
            this.closeMediaPreview();
            this.autoResizeTextarea();
            
            // Reset one-time toggle
            if (this.oneTimeEnabled) {
                this.toggleOneTime();
            }

            // Handle reply
            const replyBox = document.getElementById('reply-preview');
            const replyToId = replyBox ? replyBox.dataset.replyTo : null;
            if (replyToId) {
                formData.append('reply_to', replyToId);
            }

            const response = await fetch('/api/send-message/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.getCSRFToken()
                },
                body: formData
            });

            const data = await response.json();
            tempMessage.remove();

            if (data.success) {
                // Clear reply preview after successful send
                if (replyBox) {
                    replyBox.style.display = 'none';
                    replyBox.dataset.replyTo = '';
                }
                
                this.addMessageToUI(data.message);
                this.lastMessageTime = new Date().toISOString();
                
                // Reset one-time toggle after sending
                if (this.oneTimeEnabled) {
                    this.toggleOneTime();
                }
            } else {
                this.showNotification('Failed to send message: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch (error) {
            console.error('Error:', error);
            this.showNotification('Network error. Please check your connection and try again.', 'error');
            // Remove temporary message if it still exists
            const tempMessage = this.messagesContainer.querySelector('.message-sending');
            if (tempMessage) tempMessage.remove();
        } finally {
            this.sendBtn.disabled = false;
            const sendIcon = this.sendBtn.querySelector('.send-icon-send');
            const loadingIcon = this.sendBtn.querySelector('.send-icon-loading');
            if (sendIcon && loadingIcon) {
                sendIcon.style.display = 'inline-block';
                loadingIcon.style.display = 'none';
            } else {
                console.error('Send icons not found when restoring');
            }
            if (!this.isMobile) {
                this.messageInput.focus();
            }
        }
    }

    addMessageToUI(messageData) {
        const messageDiv = document.createElement('div');
        const messageClass = `message ${messageData.is_own ? 'message--own' : ''} ${messageData.message_type === 'system' ? 'message--system' : ''} message-fade-in`;
        messageDiv.className = messageClass;

        if (!messageData.temporary && messageData.id) {
            messageDiv.dataset.messageId = messageData.id;
        }

        let contentHtml = '';
        
        // Add reply indicator if message has reply_to (clickable to scroll to original)
        if (messageData.reply_to && messageData.reply_to.id) {
            const replyToId = messageData.reply_to.id;
            const replyToSender = messageData.reply_to.sender_name || 'Unknown';
            const replyToContent = messageData.reply_to.content ? messageData.reply_to.content.substring(0, 50) : 'Message';
            contentHtml += `
                <div class="reply-indicator" onclick="scrollToMessage('${replyToId}')" title="Click to view original message">
                    <div class="reply-content">
                        <strong>${this.escapeHtml(replyToSender)}</strong>: ${this.escapeHtml(replyToContent)}...
                    </div>
                </div>
            `;
        }
        if (messageData.one_time && messageData.consumed && !messageData.is_own) {
            // One-time message already viewed by recipient
            contentHtml = `<div class="one-time-viewed"><i data-lucide="eye" class="one-time-icon"></i><span>One-time message viewed</span></div>`;
        } else if (messageData.one_time && !messageData.consumed && !messageData.is_own) {
            // One-time message from others - show "Tap to view"
            if (messageData.temporary) {
                contentHtml = `<div class="one-time-message-temp"><i data-lucide="eye-off" class="one-time-icon"></i><span>One-time message sending...</span></div>`;
            } else {
                contentHtml = `<div class="one-time-message" onclick="consumeOneTimeMessage(${messageData.id})"><i data-lucide="eye-off" class="one-time-icon"></i><span>Tap to view one-time message</span></div>`;
            }
        } else if (messageData.one_time && messageData.is_own) {
            // Sender's view - show if opened or not
            if (messageData.consumed) {
                contentHtml = `<div class="one-time-opened"><i data-lucide="eye" class="one-time-icon"></i><span>Opened</span></div>`;
            } else {
                contentHtml = `<div class="one-time-pending"><i data-lucide="eye-off" class="one-time-icon"></i><span>Not opened yet</span></div>`;
            }
        } else if (messageData.media_type === 'image') {
            contentHtml = `<img src="${this.escapeHtml(messageData.media_url)}" alt="Image" class="message-image" onclick="openMediaViewer('${this.escapeHtml(messageData.media_url)}', 'image')" loading="lazy">`;
        } else if (messageData.media_type === 'video') {
            contentHtml = `<video controls class="message-video" preload="metadata"><source src="${this.escapeHtml(messageData.media_url)}" type="video/mp4">Your browser does not support the video tag.</video>`;
        } else {
            contentHtml = `<div class="message-text">${this.escapeHtml(messageData.content).replace(/\n/g, '<br>')}</div>`;
        }

        // Only show sender name for other people's messages in group chats
        const senderName = (messageData.is_own || messageData.message_type === 'system') ? '' : 
            (messageData.sender_name ? `<div class="sender-name">${this.escapeHtml(messageData.sender_name)}</div>` : '');
        
        const systemIcon = messageData.message_type === 'system' ? '<span class="system-message-icon">‚ÑπÔ∏è</span>' : '';

        // Build the 3-dot menu for non-system messages
        let menuHtml = '';
        if (messageData.message_type !== 'system' && messageData.id) {
            const editOption = messageData.is_own ? 
                `<div class="menu-action" onclick="editMessage('${messageData.id}'); closeAllMenus();" title="Edit">‚úèÔ∏è</div>` : '';
            const pinOption = `<div class="menu-action pin-action" onclick="togglePinMessage('${messageData.id}'); closeAllMenus();" title="Pin" data-pinned="false">üìå</div>`;
            const starOption = `<div class="menu-action star-btn" onclick="toggleStarMessage('${messageData.id}'); closeAllMenus();" title="Star" data-message-id="${messageData.id}">‚≠ê</div>`;
            
            menuHtml = `
                <div class="message-menu-container">
                    <button class="message-menu-btn" onclick="toggleMessageMenu(this)"><span></span></button>
                    <div class="message-menu">
                        <div class="menu-action" onclick="replyToMessage('${messageData.id}'); closeAllMenus();" title="Reply">‚Ü©Ô∏è</div>
                        <div class="menu-action" onclick="openReactionPicker('${messageData.id}'); closeAllMenus();" title="React">‚ù§Ô∏è</div>
                        ${starOption}
                        ${editOption}
                        ${pinOption}
                        <div class="menu-action" onclick="showDeleteModal('${messageData.id}', ${messageData.is_own}); closeAllMenus();" title="Delete">üóëÔ∏è</div>
                    </div>
                </div>
            `;
        }
        
        // Read receipt for own messages
        const readReceipt = messageData.is_own && messageData.id ? 
            `<span class="read-receipt" data-message-id="${messageData.id}" title="Sent">‚úì</span>` : '';

        messageDiv.innerHTML = `
            <div class="message-bubble">
                ${menuHtml}
                ${messageData.message_type === 'system' ? systemIcon + this.escapeHtml(messageData.content) : `
                    ${senderName}
                    <div class="message-content">${contentHtml}</div>
                    <div class="message-time">${this.escapeHtml(messageData.timestamp)}${readReceipt}</div>
                `}
            </div>
        `;

        this.messagesContainer.appendChild(messageDiv);
        this.autoScrollToBottom();
        
        // Reinitialize Lucide icons for the new elements
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

        return messageDiv;
    }

    startPolling() {
        if (this.isPolling || !this.chatId) return;

        this.isPolling = true;
        this.pollInterval = setInterval(() => {
            this.checkForNewMessages();
        }, this.messagePollingSpeed); // Fast polling for real-time feel
        
        // Start typing status polling
        this.startTypingStatusPolling();
    }

    stopPolling() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
            this.isPolling = false;
        }
        this.stopTypingStatusPolling();
    }

    async checkForNewMessages() {
        if (document.hidden || !this.chatId) return;

        try {
            // Use last message ID for more reliable polling
            let url = `/api/chat/${this.chatId}/messages/`;
            if (this.lastMessageId) {
                url += `?after_id=${this.lastMessageId}`;
            } else if (this.lastMessageTime) {
                url += `?last_message_time=${encodeURIComponent(this.lastMessageTime)}`;
            }

            const response = await fetch(url);
            if (!response.ok) return;
            
            const data = await response.json();

            if (data.messages && data.messages.length > 0) {
                let hasNewMessages = false;
                
                data.messages.forEach(message => {
                    // Check if message already exists in DOM
                    const existingMessage = this.messagesContainer.querySelector(`[data-message-id="${message.id}"]`);
                    if (!existingMessage) {
                        this.addMessageToUI(message);
                        hasNewMessages = true;
                        
                        // Update last message tracking
                        if (!this.lastMessageId || parseInt(message.id) > parseInt(this.lastMessageId)) {
                            this.lastMessageId = message.id;
                        }
                        this.lastMessageTime = message.timestamp_iso || new Date().toISOString();
                    }
                });
                
                // Play notification sound for new messages from others
                if (hasNewMessages) {
                    const lastNewMsg = data.messages[data.messages.length - 1];
                    if (!lastNewMsg.is_own) {
                        this.playMessageSound();
                    }
                }
            }
        } catch (error) {
            console.error('Error polling for messages:', error);
        }
    }
    
    playMessageSound() {
        // Optional: play a subtle notification sound
        // Can be implemented with Web Audio API or an audio element
        try {
            if ('vibrate' in navigator && this.isMobile) {
                navigator.vibrate(50); // Short vibration on mobile
            }
        } catch (e) {
            // Ignore vibration errors
        }
    }

    autoScrollToBottom() {
        if (this.messagesContainer) {
            // Use requestAnimationFrame for smoother scrolling
            requestAnimationFrame(() => {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            });
        }
    }

    initializeEmojis() {
        this.emojis = {
            smileys: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•'],
            people: ['üë∂', 'üßí', 'üë¶', 'üëß', 'üßë', 'üë®', 'üë©', 'üßì', 'üë¥', 'üëµ', 'üë±', 'üë®‚Äçü¶∞', 'üë©‚Äçü¶∞', 'üë®‚Äçü¶±', 'üë©‚Äçü¶±', 'üë®‚Äçü¶≤', 'üë©‚Äçü¶≤', 'üë®‚Äçü¶≥', 'üë©‚Äçü¶≥', 'üßî', 'üëã', 'ü§ö', 'üñê', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úå', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òù', 'üëç', 'üëé'],
            animals: ['üêµ', 'üêí', 'ü¶ç', 'ü¶ß', 'üê∂', 'üêï', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üê©', 'üê∫', 'ü¶ä', 'ü¶ù', 'üê±', 'üêà', 'üêà‚Äç‚¨õ', 'ü¶Å', 'üêØ', 'üêÖ', 'üêÜ', 'üê¥', 'üêé', 'ü¶Ñ', 'ü¶ì', 'ü¶å', 'üêÆ', 'üêÇ', 'üêÉ', 'üêÑ', 'üê∑', 'üêñ', 'üêó', 'üêΩ', 'üêè', 'üêë', 'üêê', 'üê™', 'üê´', 'ü¶ô', 'ü¶í', 'üêò'],
            food: ['üçè', 'üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂', 'üåΩ', 'ü•ï', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê', 'ü•ñ', 'üçû', 'ü•®', 'ü•Ø', 'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá'],
            activities: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõ∑', '‚õ∏', 'ü•å', 'üéø', '‚õ∑', 'üèÇ', 'ü™Ç', 'üèã', 'ü§º', 'ü§∏', '‚õπ', 'ü§∫'],
            objects: ['‚åö', 'üì±', 'üì≤', 'üíª', '‚å®', 'üñ•', 'üñ®', 'üñ±', 'üñ≤', 'üïπ', 'üóú', 'üíΩ', 'üíæ', 'üíø', 'üìÄ', 'üìº', 'üì∑', 'üì∏', 'üìπ', 'üé•', 'üìΩ', 'üéû', 'üìû', '‚òé', 'üìü', 'üì†', 'üì∫', 'üìª', 'üéô', 'üéö', 'üéõ', 'üß≠', '‚è±', '‚è≤', '‚è∞', 'üï∞', '‚åõ', '‚è≥', 'üì°', 'üîã'],
            flags: ['üè≥Ô∏è', 'üè¥', 'üèÅ', 'üö©', 'üè≥Ô∏è‚Äçüåà', 'üè≥Ô∏è‚Äç‚ößÔ∏è', 'üá∫üá≥', 'üá¶üá´', 'üá¶üáΩ', 'üá¶üá±', 'üá©üáø', 'üá¶üá∏', 'üá¶üá©', 'üá¶üá¥', 'üá¶üáÆ', 'üá¶üá∂', 'üá¶üá¨', 'üá¶üá∑', 'üá¶üá≤', 'üá¶üáº', 'üá¶üá∫', 'üá¶üáπ', 'üá¶üáø', 'üáßüá∏', 'üáßüá≠', 'üáßüá©', 'üáßüáß', 'üáßüáæ', 'üáßüá™', 'üáßüáø', 'üáßüáØ', 'üáßüá≤', 'üáßüáπ', 'üáßüá¥', 'üáßüá¶', 'üáßüáº', 'üáßüá∑', 'üáÆüá¥', 'üáªüá¨']
        };

        this.showEmojiCategory('smileys');
    }

    showEmojiCategory(category) {
        const emojiGrid = document.getElementById('emojiGrid');
        const categories = document.querySelectorAll('.emoji-category');

        if (!emojiGrid) return;

        categories.forEach(cat => cat.classList.remove('active'));
        
        // Find the clicked category button and make it active
        categories.forEach(cat => {
            if (cat.onclick && cat.onclick.toString().includes(category)) {
                cat.classList.add('active');
            }
        });

        emojiGrid.innerHTML = '';

        if (this.emojis[category]) {
            this.emojis[category].forEach(emoji => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'emoji-item';
                emojiItem.textContent = emoji;
                emojiItem.onclick = () => this.insertEmoji(emoji);
                emojiItem.title = emoji; // Add tooltip
                emojiGrid.appendChild(emojiItem);
            });
        }
    }

    insertEmoji(emoji) {
        // Check if we're in reaction mode
        const emojiPicker = document.getElementById('emojiPicker');
        if (emojiPicker && emojiPicker.classList.contains('reaction-mode')) {
            // Handle reaction
            this.addReaction(window.currentReactionMessageId, emoji);
            emojiPicker.classList.remove('reaction-mode');
            emojiPicker.style.display = 'none';
            delete window.currentReactionMessageId;
            return;
        }

        // Normal emoji insertion
        if (!this.messageInput) return;

        const input = this.messageInput;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const text = input.value;

        input.value = text.substring(0, start) + emoji + text.substring(end);
        input.selectionStart = input.selectionEnd = start + emoji.length;
        input.focus();

        if (emojiPicker) {
            emojiPicker.style.display = 'none';
        }
        this.autoResizeTextarea();
    }

    async addReaction(messageId, emoji) {
        try {
            const response = await fetch(`/api/react-message/${messageId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ emoji: emoji })
            });
            
            const data = await response.json();
            if (data.status === 'added') {
                this.updateMessageReactions(messageId, emoji, 'add');
                this.showNotification('Reaction added!', 'success');
            } else if (data.status === 'removed') {
                this.updateMessageReactions(messageId, emoji, 'remove');
                this.showNotification('Reaction removed!', 'success');
            } else {
                this.showNotification('Failed to add reaction', 'error');
            }
        } catch (error) {
            console.error('Error adding reaction:', error);
            this.showNotification('Network error', 'error');
        }
    }

    updateMessageReactions(messageId, emoji, action) {
        const container = document.getElementById(`reactions-${messageId}`);
        if (!container) return;

        if (action === 'add') {
            // Check if reaction already exists
            let existingReaction = container.querySelector(`.reaction[data-emoji="${emoji}"]`);
            if (existingReaction) {
                // Increment count (for future enhancement)
                return;
            } else {
                // Add new reaction
                const span = document.createElement('span');
                span.className = 'reaction';
                span.setAttribute('data-emoji', emoji);
                span.textContent = emoji;
                span.onclick = () => this.addReaction(messageId, emoji); // Toggle reaction
                container.appendChild(span);
            }
        } else if (action === 'remove') {
            // Remove reaction
            const reaction = container.querySelector(`.reaction[data-emoji="${emoji}"]`);
            if (reaction) {
                reaction.remove();
            }
        }
    }

    closeMediaPreview() {
        const mediaPreview = document.getElementById('mediaPreview');
        const previewImage = document.getElementById('previewImage');
        const previewVideo = document.getElementById('previewVideo');
        
        if (mediaPreview) mediaPreview.style.display = 'none';
        if (previewImage) previewImage.style.display = 'none';
        if (previewVideo) previewVideo.style.display = 'none';
    }

    getCSRFToken() {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            const [name, value] = cookie.trim().split('=');
            if (name === 'csrftoken') {
                return value;
            }
        }
        // Fallback to meta tag
        const csrfMeta = document.querySelector('meta[name="csrf-token"]');
        return csrfMeta ? csrfMeta.getAttribute('content') : '';
    }

    escapeHtml(text) {
        if (!text) return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, function(m) { return map[m]; });
    }

    showNotification(message, type = 'info') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.notification');
        existingNotifications.forEach(n => n.remove());

        const notification = document.createElement('div');
        notification.className = `notification notification--${type}`;
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            color: white;
            font-weight: 600;
            z-index: 10000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            max-width: 350px;
            word-wrap: break-word;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
            line-height: 1.4;
        `;

        const colors = { 
            success: '#10b981', 
            error: '#dc2626', 
            warning: '#f59e0b', 
            info: '#3b82f6' 
        };
        notification.style.backgroundColor = colors[type] || colors.info;

        document.body.appendChild(notification);
        
        // Animate in
        requestAnimationFrame(() => {
            notification.style.transform = 'translateX(0)';
        });
        
        // Auto-remove
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 300);
        }, 4000);
    }

    // Typing indicator - Dynamic polling
    handleTyping() {
        if (!this.isTyping) {
            this.isTyping = true;
            this.sendTypingStatus(true);
            // Start polling when user starts typing
            this.startTypingPolling();
        }
        
        this.lastTypingTime = Date.now();
        clearTimeout(this.typingTimeout);
        this.typingTimeout = setTimeout(() => {
            this.isTyping = false;
            this.sendTypingStatus(false);
            // Continue polling for a bit longer to show when others stop typing
            setTimeout(() => {
                if (!this.isTyping && Date.now() - this.lastTypingTime > 5000) {
                    this.stopTypingPolling();
                }
            }, 3000);
        }, 2000); // Stop typing status after 2 seconds of inactivity
    }
    
    sendTypingStatus(isTyping) {
        fetch(`/api/chat/${this.chatId}/typing/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': this.getCSRFToken(),
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: `is_typing=${isTyping}`
        }).catch(err => console.error('Error updating typing status:', err));
    }
    
    startTypingPolling() {
        if (this.typingPollInterval) return;
        
        this.typingPollInterval = setInterval(() => {
            // Poll for typing status when actively typing or recently typed
            if (this.isTyping || Date.now() - (this.lastTypingTime || 0) < 5000) {
                this.checkTypingStatus();
            } else if (!this.isTyping && Date.now() - this.lastTypingTime > 5000) {
                // Stop polling if not typing and enough time has passed
                this.stopTypingPolling();
            }
        }, 1000); // Poll every 1 second
    }
    
    stopTypingPolling() {
        if (this.typingPollInterval) {
            clearInterval(this.typingPollInterval);
            this.typingPollInterval = null;
        }
    }
    
    // Continuous typing status polling for all users
    startTypingStatusPolling() {
        if (this.typingStatusPollInterval) return;
        
        this.typingStatusPollInterval = setInterval(() => {
            if (this.chatId) {
                this.checkTypingStatus();
            }
        }, 1000); // Poll every 1 second for typing status
    }
    
    stopTypingStatusPolling() {
        if (this.typingStatusPollInterval) {
            clearInterval(this.typingStatusPollInterval);
            this.typingStatusPollInterval = null;
        }
    }
    
    async checkTypingStatus() {
        try {
            const response = await fetch(`/api/chat/${this.chatId}/typing-status/`);
            const data = await response.json();
            this.updateTypingIndicator(data.typing_users || []);
        } catch (error) {
            console.error('Error checking typing status:', error);
        }
    }
    
    updateTypingIndicator(users) {
        const indicator = document.getElementById('typingIndicator');
        const textEl = document.getElementById('typingText');
        
        if (!indicator || !textEl) return;
        
        if (users && users.length > 0) {
            const names = users.map(u => u.name).join(', ');
            textEl.textContent = users.length === 1 ? `${names} is typing...` : `${names} are typing...`;
            indicator.style.display = 'block';
        } else {
            indicator.style.display = 'none';
        }
    }
    
    // One-time message toggle
    toggleOneTime() {
        this.oneTimeEnabled = !this.oneTimeEnabled;

        // Get button fresh each time
        const btn = document.getElementById('oneTimeBtn');

        if (!btn) {
            console.error('One-time button not found in DOM');
            return;
        }

        // Update button appearance by replacing inner HTML
        if (this.oneTimeEnabled) {
            btn.classList.add('active');
            btn.innerHTML = '<i data-lucide="eye" class="action-icon"></i>';
            btn.title = 'One-time message enabled - click to disable';
        } else {
            btn.classList.remove('active');
            btn.innerHTML = '<i data-lucide="eye-off" class="action-icon"></i>';
            btn.title = 'Send as one-time message';
        }

        // Re-initialize icons
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    // Consume one-time message
    async consumeOneTimeMessage(messageId) {
        console.log('consumeOneTimeMessage called with messageId:', messageId);
        try {
            const response = await fetch(`/api/consume-message/${messageId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            if (data.success) {
                // Show full-screen modal with message content
                this.showOneTimeModal(data, messageId);
            } else {
                this.showNotification('Failed to view message', 'error');
            }
        } catch (error) {
            console.error('Error consuming message:', error);
            this.showNotification('Network error', 'error');
        }
    }
    
    showOneTimeModal(data, messageId) {
        // Create full-screen modal like WhatsApp
        const modal = document.createElement('div');
        modal.className = 'one-time-fullscreen-modal';
        modal.id = 'oneTimeViewModal';
        
        let bodyContent = '';
        if (data.media_type === 'image') {
            bodyContent = `<img src="${this.escapeHtml(data.media_url)}" alt="One-time image" class="one-time-fullscreen-media">`;
        } else if (data.media_type === 'video') {
            bodyContent = `<video controls autoplay class="one-time-fullscreen-media"><source src="${this.escapeHtml(data.media_url)}" type="video/mp4">Your browser does not support the video tag.</video>`;
        } else {
            bodyContent = `<div class="one-time-fullscreen-text">${this.escapeHtml(data.content).replace(/\n/g, '<br>')}</div>`;
        }
        
        modal.innerHTML = `
            <div class="one-time-fullscreen-header">
                <div class="one-time-fullscreen-info">
                    <i data-lucide="eye" class="one-time-icon"></i>
                    <span>One-time ${data.media_type === 'image' ? 'photo' : data.media_type === 'video' ? 'video' : 'message'}</span>
                </div>
                <button class="one-time-close-btn" onclick="window.chatApp.closeOneTimeModal('${messageId}')">‚úï</button>
            </div>
            <div class="one-time-fullscreen-body">
                ${bodyContent}
            </div>
            <div class="one-time-fullscreen-footer">
                <span>This message will disappear after you close it</span>
            </div>
        `;
        
        // Prevent accidental close, require explicit close button
        modal.onclick = (e) => {
            if (e.target === modal) {
                // Show hint that they need to use close button
                const footer = modal.querySelector('.one-time-fullscreen-footer span');
                if (footer) {
                    footer.textContent = 'Tap ‚úï to close';
                    footer.style.color = '#fbbf24';
                }
            }
        };
        
        document.body.appendChild(modal);
        
        // Initialize lucide icons in modal
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    closeOneTimeModal(messageId) {
        const modal = document.getElementById('oneTimeViewModal');
        if (modal) {
            modal.remove();
        }
        // Update the message in UI to show it's been viewed
        this.updateMessageAsViewed(messageId);
    }
    
    updateMessageAsViewed(messageId) {
        const messageEl = this.messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
        if (messageEl) {
            const contentEl = messageEl.querySelector('.message-content');
            if (contentEl) {
                contentEl.innerHTML = `<div class="one-time-viewed"><i data-lucide="eye" class="one-time-icon"></i><span>One-time message viewed</span></div>`;
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }
        }
    }
    
    // Kept for backwards compatibility
    updateMessageAsConsumed(messageId) {
        this.updateMessageAsViewed(messageId);
    }
    
    // Mark message as read
    async markMessageRead(messageId) {
        try {
            await fetch(`/api/mark-read/${messageId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.getCSRFToken()
                }
            });
        } catch (error) {
            console.error('Error marking message read:', error);
        }
    }

    // Cleanup method
    destroy() {
        this.stopPolling();
        this.stopTypingPolling();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        if (this.websocket) {
            this.websocket.close();
        }
        if (this.typingTimeout) {
            clearTimeout(this.typingTimeout);
        }
    }
}

// Global functions for UI interactions
function toggleEmojiPicker() {
    const picker = document.getElementById('emojiPicker');
    if (picker) {
        const isVisible = picker.style.display !== 'none' && picker.style.display !== '';
        picker.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible && window.chatApp) {
            // Ensure smileys category is shown by default
            window.chatApp.showEmojiCategory('smileys');
        }
    }
}

function showEmojiCategory(category) {
    if (window.chatApp) {
        window.chatApp.showEmojiCategory(category);
    }
}

function toggleOneTime() {
    if (window.chatApp) {
        window.chatApp.toggleOneTime();
    }
}

function consumeOneTimeMessage(messageId) {
    if (window.chatApp) {
        window.chatApp.consumeOneTimeMessage(messageId);
    }
}

// Mobile Navigation Functions
function toggleMobileSidebar() {
    if (window.chatApp) {
        if (window.chatApp.sidebar.classList.contains('show')) {
            window.chatApp.closeMobileSidebar();
        } else {
            window.chatApp.openMobileSidebar();
        }
    }
}

function closeMobileSidebar() {
    if (window.chatApp) {
        window.chatApp.closeMobileSidebar();
    }
}

function goBack() {
    // Check if we have a sidebar open first
    if (window.chatApp && window.chatApp.sidebar.classList.contains('show')) {
        window.chatApp.closeMobileSidebar();
        return;
    }
    
    // Try to go back in history first
    if (window.history.length > 1) {
        window.history.back();
    } else {
        // Fallback to dashboard or chat list
        window.location.href = '/dashboard/';
    }
}

function handleMediaSelect(event) {
    const file = event.target.files[0];
    if (!file || !window.chatApp) return;

    // Validate file type and size
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
        window.chatApp.showNotification('File size must be less than 10MB', 'error');
        return;
    }

    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'video/ogg'];
    if (!allowedTypes.includes(file.type)) {
        window.chatApp.showNotification('Only images (JPEG, PNG, GIF, WebP) and videos (MP4, WebM, OGG) are allowed', 'error');
        return;
    }

    window.chatApp.selectedMedia = file;

    // Show preview
    const preview = document.getElementById('mediaPreview');
    const previewImage = document.getElementById('previewImage');
    const previewVideo = document.getElementById('previewVideo');

    if (!preview || !previewImage || !previewVideo) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        if (file.type.startsWith('image/')) {
            previewImage.src = e.target.result;
            previewImage.style.display = 'block';
            previewVideo.style.display = 'none';
        } else {
            previewVideo.src = e.target.result;
            previewVideo.style.display = 'block';
            previewImage.style.display = 'none';
        }
        preview.style.display = 'block';
    };
    reader.onerror = function() {
        window.chatApp.showNotification('Error reading file', 'error');
    };
    reader.readAsDataURL(file);
}

function closeMediaPreview() {
    if (window.chatApp) {
        window.chatApp.closeMediaPreview();
        window.chatApp.selectedMedia = null;
    }
    
    const mediaInput = document.getElementById('mediaInput');
    if (mediaInput) {
        mediaInput.value = '';
    }
}

function openMediaViewer(url, type) {
    const viewer = document.getElementById('mediaViewer');
    const viewerImage = document.getElementById('viewerImage');
    const viewerVideo = document.getElementById('viewerVideo');

    if (!viewer || !viewerImage || !viewerVideo) return;

    if (type === 'image') {
        viewerImage.src = url;
        viewerImage.style.display = 'block';
        viewerVideo.style.display = 'none';
    } else {
        viewerVideo.src = url;
        viewerVideo.style.display = 'block';
        viewerImage.style.display = 'none';
    }

    viewer.style.display = 'flex';
    document.body.style.overflow = 'hidden';
}

function closeMediaViewer() {
    const viewer = document.getElementById('mediaViewer');
    if (viewer) {
        viewer.style.display = 'none';
    }
    document.body.style.overflow = '';
}

function toggleJoinRequests() {
    const panel = document.getElementById('joinRequestsPanel');
    if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
}

async function manageJoinRequest(requestId, action) {
    try {
        const response = await fetch('/api/manage-join-request/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
            },
            body: JSON.stringify({
                request_id: requestId,
                action: action
            })
        });

        const data = await response.json();
        
        if (data.success) {
            const requestItem = document.querySelector(`[data-request-id="${requestId}"]`);
            if (requestItem) {
                requestItem.style.opacity = '0.5';
                requestItem.style.transform = 'scale(0.95)';
                setTimeout(() => requestItem.remove(), 300);
            }

            const actionText = action === 'approve' ? 'approved' : 'rejected';
            if (window.chatApp) {
                window.chatApp.showNotification(`${data.username}'s request ${actionText}`, 'success');
            }
        } else {
            if (window.chatApp) {
                window.chatApp.showNotification('Error: ' + data.error, 'error');
            }
        }
    } catch (error) {
        console.error('Error:', error);
        if (window.chatApp) {
            window.chatApp.showNotification('Network error. Please try again.', 'error');
        }
    }
}

// Modal Functions for Invite Link
function shareInviteLink() {
    const modal = document.getElementById('inviteLinkModal');
    if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Focus the input for easier copying
        setTimeout(() => {
            const linkInput = document.getElementById('shareInviteLink');
            if (linkInput) {
                linkInput.select();
                linkInput.setSelectionRange(0, 99999);
            }
        }, 100);
    }
}

function closeInviteLinkModal() {
    const modal = document.getElementById('inviteLinkModal');
    if (modal) {
        modal.style.animation = 'modalFadeOut 0.2s ease-in-out forwards';
        setTimeout(() => {
            modal.style.display = 'none';
            modal.style.animation = '';
            document.body.style.overflow = '';
        }, 200);
    }
}

function closeInviteLinkModalOutside(event) {
    if (event.target === event.currentTarget) {
        closeInviteLinkModal();
    }
}

async function copyShareLink() {
    const linkInput = document.getElementById('shareInviteLink');
    if (!linkInput) return;
    
    linkInput.select();
    linkInput.setSelectionRange(0, 99999);
    
    try {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(linkInput.value);
            if (window.chatApp) {
                window.chatApp.showNotification('‚úÖ Invite link copied to clipboard!', 'success');
            }
        } else {
            // Fallback for older browsers or non-HTTPS
            const successful = document.execCommand('copy');
            if (successful && window.chatApp) {
                window.chatApp.showNotification('üìã Invite link copied to clipboard!', 'success');
            } else {
                throw new Error('Copy command failed');
            }
        }
    } catch (error) {
        console.error('Failed to copy text:', error);
        if (window.chatApp) {
            window.chatApp.showNotification('‚ùå Failed to copy link. Please copy manually.', 'error');
        }
        
        // Select the text again so user can copy manually
        linkInput.select();
    }
}

function getCSRFToken() {
    // Try cookies first
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'csrftoken') {
            return value;
        }
    }
    
    // Fallback to meta tag
    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    if (csrfMeta) {
        return csrfMeta.getAttribute('content');
    }
    
    // Last fallback to form input
    const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        return csrfInput.value;
    }
    
    return '';
}

// Utility function for notifications
function showNotification(message, type) {
    if (window.chatApp) {
        window.chatApp.showNotification(message, type);
    } else {
        // Fallback notification system
        alert(message);
    }
}

// Group creation helpers (kept lightweight for chat page use)
let createdGroupId = null;

function openCreateGroupModal() {
    const modal = document.getElementById('createGroupModal');
    if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }
}

function closeCreateGroupModal(event) {
    if (event && event.target && event.currentTarget && event.target !== event.currentTarget) {
        return;
    }
    const modal = document.getElementById('createGroupModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
    const form = document.getElementById('createGroupForm');
    if (form) {
        form.reset();
    }
}

async function submitCreateGroupFromChat(event) {
    if (event) event.preventDefault();

    const name = document.getElementById('groupName')?.value.trim() || '';
    const description = document.getElementById('groupDescription')?.value.trim() || '';
    const maxParticipantsRaw = document.getElementById('maxParticipants')?.value;
    const maxParticipants = parseInt(maxParticipantsRaw || '50', 10);
    const isPublic = document.getElementById('isPublic')?.checked || false;

    if (!name) {
        showNotification('Group name is required', 'error');
        return;
    }

    try {
        const response = await fetch('/api/create-group/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken(),
            },
            body: JSON.stringify({
                name,
                description,
                max_participants: isNaN(maxParticipants) ? 50 : maxParticipants,
                is_public: isPublic
            })
        });

        const data = await response.json();

        if (data.success) {
            createdGroupId = data.group?.id;
            document.getElementById('createdGroupName').textContent = data.group?.name || 'New Group';
            document.getElementById('createdInviteLink').value = data.group?.invite_link || '';
            closeCreateGroupModal();
            const confirmation = document.getElementById('groupCreatedModal');
            if (confirmation) {
                confirmation.style.display = 'flex';
                document.body.style.overflow = 'hidden';
            }
        } else {
            showNotification(`Failed to create group: ${data.error || 'Unknown error'}`, 'error');
        }
    } catch (err) {
        console.error('Create group error:', err);
        showNotification('Network error. Please try again.', 'error');
    }
}

function closeGroupCreatedModal(event) {
    if (event && event.target && event.currentTarget && event.target !== event.currentTarget) {
        return;
    }
    const modal = document.getElementById('groupCreatedModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
}

function copyCreatedInviteLink() {
    const linkInput = document.getElementById('createdInviteLink');
    if (!linkInput) return;
    linkInput.select();
    linkInput.setSelectionRange(0, 99999);
    const copied = document.execCommand('copy');
    showNotification(copied ? 'Invite link copied to clipboard!' : 'Copy failed, please copy manually.', copied ? 'success' : 'error');
}

function goToCreatedGroup() {
    if (createdGroupId) {
        window.location.href = `/chat/${createdGroupId}/`;
    }
}

// Add CSS animation for modal fade out
const style = document.createElement('style');
style.textContent = `
    @keyframes modalFadeOut {
        from {
            opacity: 1;
            backdrop-filter: blur(4px);
        }
        to {
            opacity: 0;
            backdrop-filter: blur(0px);
        }
    }
`;
document.head.appendChild(style);

// Initialize enhanced chat when page loads
document.addEventListener('DOMContentLoaded', function() {
    try {
        window.chatApp = new EnhancedChatApp();
    } catch (error) {
        console.error('Error initializing chat app:', error);
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window.chatApp && typeof window.chatApp.destroy === 'function') {
        window.chatApp.destroy();
    }
});

// Handle online/offline status
window.addEventListener('online', function() {
    if (window.chatApp && !window.chatApp.isPolling) {
        window.chatApp.startPolling();
    }
});

window.addEventListener('offline', function() {
    if (window.chatApp) {
        window.chatApp.stopPolling();
    }
});

// =============================================
// GROUP SETTINGS FUNCTIONS
// =============================================

let currentMemberToRemove = null;

function openGroupSettings() {
    const modal = document.getElementById('groupSettingsModal');
    if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        loadGroupMembers();
        lucide.createIcons();
    }
}

function closeGroupSettings() {
    const modal = document.getElementById('groupSettingsModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
        hideEditGroupForm();
    }
}

function closeGroupSettingsOutside(event) {
    if (event.target.id === 'groupSettingsModal') {
        closeGroupSettings();
    }
}

async function loadGroupMembers() {
    const membersList = document.getElementById('membersList');
    const chatId = {{ chat.id }};
    
    try {
        const response = await fetch(`/api/group/${chatId}/details/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update member count
            document.getElementById('groupMemberCount').textContent = 
                `${data.group.participant_count} member${data.group.participant_count !== 1 ? 's' : ''}`;
            document.getElementById('membersCountLabel').textContent = 
                `${data.group.participant_count} Members`;
            
            // Render members
            membersList.innerHTML = data.members.map(member => `
                <div class="member-item" data-user-id="${member.id}">
                    <img src="${member.profile_picture}" alt="${member.full_name}" 
                         class="member-avatar"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="member-avatar-fallback" style="display: none;">
                        ${member.full_name.split(' ').map(n => n[0]).join('').substring(0, 2)}
                    </div>
                    <div class="member-info">
                        <div class="member-name">
                            ${member.full_name}
                            ${member.is_admin ? '<span class="admin-badge">Admin</span>' : ''}
                        </div>
                        <div class="member-status">
                            ${member.is_online ? '<span class="online-dot"></span>Online' : '@' + member.username}
                        </div>
                    </div>
                    ${data.group.is_admin && !member.is_admin ? `
                        <div class="member-actions">
                            <button class="remove-member-btn" onclick="confirmRemoveMember(${member.id}, '${member.full_name.replace(/'/g, "\\'")}')">
                                <i data-lucide="user-x"></i>
                            </button>
                        </div>
                    ` : ''}
                </div>
            `).join('');
            
            // Re-initialize Lucide icons for new elements
            lucide.createIcons();
        } else {
            membersList.innerHTML = `<p style="text-align: center; color: #ef4444;">Failed to load members</p>`;
        }
    } catch (error) {
        console.error('Error loading group members:', error);
        membersList.innerHTML = `<p style="text-align: center; color: #ef4444;">Error loading members</p>`;
    }
}

function showShareInviteLink() {
    closeGroupSettings();
    // Use existing invite link modal if available
    const inviteModal = document.getElementById('inviteLinkModal');
    if (inviteModal) {
        inviteModal.style.display = 'flex';
    }
}

function showEditGroupForm() {
    const form = document.getElementById('editGroupForm');
    if (form) {
        form.style.display = 'block';
        form.scrollIntoView({ behavior: 'smooth' });
    }
}

function hideEditGroupForm() {
    const form = document.getElementById('editGroupForm');
    if (form) {
        form.style.display = 'none';
    }
}

async function saveGroupSettings() {
    const chatId = {{ chat.id }};
    const name = document.getElementById('editGroupName').value.trim();
    const description = document.getElementById('editGroupDescription').value.trim();
    const maxParticipants = parseInt(document.getElementById('editMaxParticipants').value);
    const isPublic = document.getElementById('editIsPublic').checked;
    
    if (!name) {
        alert('Group name cannot be empty');
        return;
    }
    
    try {
        const response = await fetch(`/api/group/${chatId}/update-settings/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                name: name,
                description: description,
                max_participants: maxParticipants,
                is_public: isPublic
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Update displays
            document.getElementById('groupNameDisplay').textContent = name;
            document.getElementById('groupDescriptionDisplay').innerHTML = description || '<em>No description</em>';
            
            // Update chat header
            const headerTitle = document.querySelector('.chat-user-details h4');
            if (headerTitle) {
                headerTitle.textContent = name;
            }
            
            hideEditGroupForm();
            showToast('Group settings updated successfully', 'success');
        } else {
            alert(data.error || 'Failed to update settings');
        }
    } catch (error) {
        console.error('Error saving group settings:', error);
        alert('Failed to save settings. Please try again.');
    }
}

function confirmLeaveGroup() {
    const modal = document.getElementById('leaveGroupModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeLeaveGroupModal() {
    const modal = document.getElementById('leaveGroupModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

async function executeLeaveGroup() {
    const chatId = {{ chat.id }};
    
    try {
        const response = await fetch(`/api/group/${chatId}/leave/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Redirect to dashboard
            window.location.href = '/dashboard/';
        } else {
            alert(data.error || 'Failed to leave group');
        }
    } catch (error) {
        console.error('Error leaving group:', error);
        alert('Failed to leave group. Please try again.');
    }
}

function confirmRemoveMember(userId, fullName) {
    currentMemberToRemove = { id: userId, name: fullName };
    
    const modal = document.getElementById('removeMemberModal');
    const message = document.getElementById('removeMemberMessage');
    
    if (modal && message) {
        message.innerHTML = `Are you sure you want to remove <strong>${fullName}</strong> from the group?`;
        modal.style.display = 'flex';
    }
}

function closeRemoveMemberModal() {
    const modal = document.getElementById('removeMemberModal');
    if (modal) {
        modal.style.display = 'none';
    }
    currentMemberToRemove = null;
}

async function executeRemoveMember() {
    if (!currentMemberToRemove) return;
    
    const chatId = {{ chat.id }};
    const userId = currentMemberToRemove.id;
    
    try {
        const response = await fetch(`/api/group/${chatId}/remove-member/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ user_id: userId })
        });
        
        const data = await response.json();
        
        if (data.success) {
            closeRemoveMemberModal();
            loadGroupMembers(); // Refresh the member list
            showToast(data.message, 'success');
        } else {
            alert(data.error || 'Failed to remove member');
        }
    } catch (error) {
        console.error('Error removing member:', error);
        alert('Failed to remove member. Please try again.');
    }
}

// Helper function to show toast notifications
function showToast(message, type = 'info') {
    // Create toast element if it doesn't exist
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        document.body.appendChild(toastContainer);
    }
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.style.cssText = `
        padding: 12px 20px;
        border-radius: 8px;
        background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        font-size: 0.9rem;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        animation: slideIn 0.3s ease;
    `;
    toast.textContent = message;
    
    toastContainer.appendChild(toast);
    
    // Remove toast after 3 seconds
    setTimeout(() => {
        toast.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// =============================================
// P2P FILE SHARING - WebRTC Implementation
// =============================================

class P2PFileShare {
    constructor() {
        this.chatId = {{ chat.id }};
        this.currentUserId = {{ user.id }};
        this.peerConnection = null;
        this.dataChannel = null;
        this.selectedFile = null;
        this.selectedRecipient = null;
        this.currentStep = 1;
        this.isReceiving = false;
        this.receivedChunks = [];
        this.receivedSize = 0;
        this.fileMetadata = null;
        this.transferStartTime = null;
        this.signalPollingInterval = null;
        this.incomingRequest = null;
        this.isTransferActive = false;
        this.heartbeatInterval = null;
        this.lastHeartbeat = null;
        this.connectionTimeout = null;
        this.waitingForAccept = false;
        this.acceptTimeout = null;
        
        // WebRTC configuration with STUN servers
        this.rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };
        
        // Chunk size for file transfer (16KB)
        this.CHUNK_SIZE = 16384;
        
        // Timeouts
        this.ACCEPT_TIMEOUT = 60000; // 60 seconds to accept
        this.HEARTBEAT_INTERVAL = 3000; // 3 seconds
        this.CONNECTION_TIMEOUT = 15000; // 15 seconds without heartbeat
        
        // Start polling for signals
        this.startSignalPolling();
        
        // Handle page unload - notify peer
        this.boundBeforeUnload = this.handleBeforeUnload.bind(this);
        window.addEventListener('beforeunload', this.boundBeforeUnload);
    }
    
    handleBeforeUnload() {
        // Send cancel signal if we're in an active transfer that hasn't completed
        if (this.selectedRecipient && !this.transferComplete && (this.isTransferActive || this.waitingForAccept || this.isReceiving)) {
            // Use sendBeacon for reliable delivery during page unload
            const data = JSON.stringify({
                target_user_id: this.selectedRecipient.id,
                chat_id: this.chatId,
                signal_type: 'transfer-cancelled',
                signal_data: { reason: 'User left the page' }
            });
            navigator.sendBeacon('/api/p2p/send-signal/', new Blob([data], { type: 'application/json' }));
        }
    }
    
    // Start polling for incoming P2P signals
    startSignalPolling() {
        this.signalPollingInterval = setInterval(() => this.pollSignals(), 2000);
    }
    
    stopSignalPolling() {
        if (this.signalPollingInterval) {
            clearInterval(this.signalPollingInterval);
            this.signalPollingInterval = null;
        }
    }
    
    async pollSignals() {
        try {
            const response = await fetch(`/api/p2p/${this.chatId}/signals/`, {
                headers: { 'X-CSRFToken': getCookie('csrftoken') }
            });
            const data = await response.json();
            
            if (data.success && data.signals.length > 0) {
                for (const signal of data.signals) {
                    await this.handleIncomingSignal(signal);
                }
            }
        } catch (error) {
            console.error('Error polling P2P signals:', error);
        }
    }
    
    async handleIncomingSignal(signal) {
        console.log('Received P2P signal:', signal.signal_type);
        
        switch (signal.signal_type) {
            case 'file-request':
                this.showIncomingFileRequest(signal);
                break;
            case 'file-accept':
                await this.onFileAccepted(signal);
                break;
            case 'file-reject':
                this.onFileRejected(signal);
                break;
            case 'offer':
                await this.handleOffer(signal);
                break;
            case 'answer':
                await this.handleAnswer(signal);
                break;
            case 'ice-candidate':
                await this.handleIceCandidate(signal);
                break;
            case 'transfer-cancelled':
                this.handleTransferCancelled(signal);
                break;
            case 'heartbeat':
                this.handleHeartbeat(signal);
                break;
            case 'heartbeat-ack':
                this.handleHeartbeatAck(signal);
                break;
        }
    }
    
    // Handle transfer cancellation from peer
    handleTransferCancelled(signal) {
        console.log('Transfer cancelled by peer:', signal.signal_data.reason);
        
        // Close any open modals
        document.getElementById('p2pIncomingModal').style.display = 'none';
        document.getElementById('p2pReceivingModal').style.display = 'none';
        
        // Update sender modal if open
        if (document.getElementById('p2pFileShareModal').style.display === 'flex') {
            this.updateTransferStatus('error', 'Transfer Cancelled', signal.signal_data.reason || 'Peer disconnected');
            setTimeout(() => closeP2PFileShare(), 3000);
        }
        
        showToast('File transfer was cancelled: ' + (signal.signal_data.reason || 'Peer disconnected'), 'error');
        this.cleanupTransfer();
    }
    
    // Start heartbeat when transfer is active
    startHeartbeat() {
        this.lastHeartbeat = Date.now();
        
        this.heartbeatInterval = setInterval(() => {
            if (this.selectedRecipient) {
                this.sendSignal(this.selectedRecipient.id, 'heartbeat', { timestamp: Date.now() });
            }
        }, this.HEARTBEAT_INTERVAL);
        
        // Check for connection timeout
        this.connectionTimeout = setInterval(() => {
            if (this.lastHeartbeat && (Date.now() - this.lastHeartbeat > this.CONNECTION_TIMEOUT)) {
                console.log('Connection timeout - no heartbeat received');
                this.handleConnectionLost();
            }
        }, 5000);
    }
    
    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
        if (this.connectionTimeout) {
            clearInterval(this.connectionTimeout);
            this.connectionTimeout = null;
        }
    }
    
    handleHeartbeat(signal) {
        // Respond with ack
        if (this.selectedRecipient) {
            this.sendSignal(signal.from_user_id, 'heartbeat-ack', { timestamp: Date.now() });
        }
        this.lastHeartbeat = Date.now();
    }
    
    handleHeartbeatAck(signal) {
        this.lastHeartbeat = Date.now();
    }
    
    handleConnectionLost() {
        this.updateTransferStatus('error', 'Connection Lost', 'Peer appears to be disconnected');
        showToast('Connection lost - peer may have disconnected', 'error');
        
        setTimeout(() => {
            closeP2PFileShare();
            document.getElementById('p2pReceivingModal').style.display = 'none';
        }, 3000);
        
        this.cleanupTransfer();
    }
    
    showIncomingFileRequest(signal) {
        this.incomingRequest = signal;
        
        document.getElementById('p2pSenderAvatar').src = signal.signal_data.sender_avatar || '/static/images/default-avatar.png';
        document.getElementById('p2pSenderName').textContent = signal.from_full_name;
        document.getElementById('p2pIncomingFileName').textContent = signal.signal_data.file_name;
        document.getElementById('p2pIncomingFileSize').textContent = this.formatFileSize(signal.signal_data.file_size);
        
        document.getElementById('p2pIncomingModal').style.display = 'flex';
        lucide.createIcons();
    }
    
    async sendSignal(targetUserId, signalType, signalData) {
        try {
            await fetch('/api/p2p/send-signal/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    target_user_id: targetUserId,
                    chat_id: this.chatId,
                    signal_type: signalType,
                    signal_data: signalData
                })
            });
        } catch (error) {
            console.error('Error sending P2P signal:', error);
        }
    }
    
    // Initialize WebRTC connection as offerer
    async initConnection(isOfferer = true) {
        this.peerConnection = new RTCPeerConnection(this.rtcConfig);
        this.isTransferActive = true;
        
        // Handle ICE candidates
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                this.sendSignal(this.selectedRecipient.id, 'ice-candidate', {
                    candidate: event.candidate
                });
            }
        };
        
        this.peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', this.peerConnection.connectionState);
            
            switch (this.peerConnection.connectionState) {
                case 'connected':
                    this.updateTransferStatus('transferring', 'Connected!', 'Starting file transfer...');
                    this.startHeartbeat();
                    break;
                case 'disconnected':
                    this.updateTransferStatus('error', 'Disconnected', 'Peer connection was interrupted');
                    showToast('Connection interrupted', 'error');
                    setTimeout(() => this.handleConnectionLost(), 2000);
                    break;
                case 'failed':
                    this.updateTransferStatus('error', 'Connection Failed', 'Could not establish P2P connection');
                    showToast('Failed to connect to peer', 'error');
                    setTimeout(() => closeP2PFileShare(), 3000);
                    break;
                case 'closed':
                    console.log('Connection closed');
                    this.stopHeartbeat();
                    break;
            }
        };
        
        this.peerConnection.oniceconnectionstatechange = () => {
            console.log('ICE connection state:', this.peerConnection.iceConnectionState);
            if (this.peerConnection.iceConnectionState === 'failed') {
                this.updateTransferStatus('error', 'Connection Failed', 'Network connection could not be established');
            }
        };
        
        if (isOfferer) {
            // Create data channel
            this.dataChannel = this.peerConnection.createDataChannel('fileTransfer', {
                ordered: true
            });
            this.setupDataChannel(this.dataChannel);
            
            // Create and send offer
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);
            
            this.sendSignal(this.selectedRecipient.id, 'offer', {
                offer: this.peerConnection.localDescription
            });
        } else {
            // Handle incoming data channel
            this.peerConnection.ondatachannel = (event) => {
                this.dataChannel = event.channel;
                this.setupDataChannel(this.dataChannel);
            };
        }
    }
    
    setupDataChannel(channel) {
        channel.binaryType = 'arraybuffer';
        
        channel.onopen = () => {
            console.log('Data channel opened');
            this.isTransferActive = true;
            if (this.selectedFile && !this.isReceiving) {
                this.startFileTransfer();
            }
        };
        
        channel.onclose = () => {
            console.log('Data channel closed');
            // If transfer wasn't complete, show error
            if (this.isTransferActive && !this.transferComplete) {
                this.updateTransferStatus('error', 'Connection Closed', 'Data channel was closed unexpectedly');
                showToast('Connection closed unexpectedly', 'error');
                setTimeout(() => {
                    closeP2PFileShare();
                    document.getElementById('p2pReceivingModal').style.display = 'none';
                }, 2000);
            }
            this.isTransferActive = false;
        };
        
        channel.onerror = (error) => {
            console.error('Data channel error:', error);
            this.updateTransferStatus('error', 'Transfer Error', 'Connection error occurred');
            showToast('Transfer error occurred', 'error');
        };
        
        channel.onmessage = (event) => {
            this.handleDataChannelMessage(event.data);
        };
    }
    
    async handleOffer(signal) {
        this.selectedRecipient = { id: signal.from_user_id };
        await this.initConnection(false);
        
        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(signal.signal_data.offer));
        
        const answer = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(answer);
        
        this.sendSignal(signal.from_user_id, 'answer', {
            answer: this.peerConnection.localDescription
        });
    }
    
    async handleAnswer(signal) {
        if (this.peerConnection) {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(signal.signal_data.answer));
        }
    }
    
    async handleIceCandidate(signal) {
        if (this.peerConnection && signal.signal_data.candidate) {
            try {
                await this.peerConnection.addIceCandidate(new RTCIceCandidate(signal.signal_data.candidate));
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }
    }
    
    // Start sending file
    startFileTransfer() {
        if (!this.dataChannel || this.dataChannel.readyState !== 'open') {
            console.error('Data channel not ready');
            return;
        }
        
        this.transferStartTime = Date.now();
        
        // Send file metadata first
        const metadata = {
            type: 'metadata',
            name: this.selectedFile.name,
            size: this.selectedFile.size,
            mimeType: this.selectedFile.type
        };
        this.dataChannel.send(JSON.stringify(metadata));
        
        // Read and send file in chunks
        const reader = new FileReader();
        let offset = 0;
        
        const readSlice = () => {
            const slice = this.selectedFile.slice(offset, offset + this.CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };
        
        reader.onload = (e) => {
            this.dataChannel.send(e.target.result);
            offset += e.target.result.byteLength;
            
            // Update progress
            const progress = (offset / this.selectedFile.size) * 100;
            this.updateProgress(progress, offset, this.selectedFile.size);
            
            if (offset < this.selectedFile.size) {
                // Continue sending
                readSlice();
            } else {
                // Transfer complete
                this.transferComplete = true;
                this.dataChannel.send(JSON.stringify({ type: 'complete' }));
                this.updateTransferStatus('complete', 'Transfer Complete!', 'File sent successfully');
                showToast('File sent successfully!', 'success');
                setTimeout(() => {
                    closeP2PFileShare();
                    this.cleanupTransfer();
                }, 2000);
            }
        };
        
        readSlice();
    }
    
    // Handle incoming data
    handleDataChannelMessage(data) {
        if (typeof data === 'string') {
            const message = JSON.parse(data);
            
            if (message.type === 'metadata') {
                this.fileMetadata = message;
                this.receivedChunks = [];
                this.receivedSize = 0;
                this.transferStartTime = Date.now();
                
                document.getElementById('p2pReceivingFileName').textContent = message.name;
                document.getElementById('p2pReceivingModal').style.display = 'flex';
                document.getElementById('p2pIncomingModal').style.display = 'none';
                lucide.createIcons();
            } else if (message.type === 'complete') {
                this.completeReceive();
            }
        } else {
            // Binary data (file chunk)
            this.receivedChunks.push(data);
            this.receivedSize += data.byteLength;
            
            // Update receiving progress
            const progress = (this.receivedSize / this.fileMetadata.size) * 100;
            this.updateReceivingProgress(progress);
        }
    }
    
    completeReceive() {
        this.transferComplete = true;
        
        // Combine chunks and create download
        const blob = new Blob(this.receivedChunks, { type: this.fileMetadata.mimeType });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const a = document.createElement('a');
        a.href = url;
        a.download = this.fileMetadata.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        document.getElementById('p2pReceivingStatus').textContent = 'Download complete!';
        document.getElementById('p2pReceivingProgressFill').style.background = 'linear-gradient(90deg, #10b981 0%, #059669 100%)';
        showToast(`Received: ${this.fileMetadata.name}`, 'success');
        
        setTimeout(() => {
            document.getElementById('p2pReceivingModal').style.display = 'none';
            this.cleanupTransfer();
        }, 2000);
    }
    
    updateProgress(percent, transferred, total) {
        document.getElementById('p2pProgressFill').style.width = percent + '%';
        document.getElementById('p2pProgressPercent').textContent = Math.round(percent) + '%';
        document.getElementById('p2pTransferred').textContent = this.formatFileSize(transferred);
        
        // Calculate speed
        const elapsed = (Date.now() - this.transferStartTime) / 1000;
        const speed = transferred / elapsed;
        document.getElementById('p2pTransferSpeed').textContent = this.formatFileSize(speed) + '/s';
    }
    
    updateReceivingProgress(percent) {
        document.getElementById('p2pReceivingProgressFill').style.width = percent + '%';
        document.getElementById('p2pReceivingPercent').textContent = Math.round(percent) + '%';
        
        const elapsed = (Date.now() - this.transferStartTime) / 1000;
        const speed = this.receivedSize / elapsed;
        document.getElementById('p2pReceivingSpeed').textContent = this.formatFileSize(speed) + '/s';
    }
    
    updateTransferStatus(status, title, description) {
        const iconEl = document.getElementById('p2pStatusIcon');
        const titleEl = document.getElementById('p2pStatusText');
        const descEl = document.getElementById('p2pStatusDesc');
        
        iconEl.className = 'p2p-status-icon ' + status;
        
        let iconHtml = '';
        switch (status) {
            case 'connecting': iconHtml = '<i data-lucide="wifi"></i>'; break;
            case 'transferring': iconHtml = '<i data-lucide="loader-2"></i>'; break;
            case 'complete': iconHtml = '<i data-lucide="check-circle"></i>'; break;
            case 'error': iconHtml = '<i data-lucide="x-circle"></i>'; break;
        }
        iconEl.innerHTML = iconHtml;
        
        titleEl.textContent = title;
        descEl.textContent = description;
        lucide.createIcons();
    }
    
    formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Cleanup just the transfer state (not the whole P2P system)
    cleanupTransfer() {
        this.stopHeartbeat();
        
        if (this.acceptTimeout) {
            clearTimeout(this.acceptTimeout);
            this.acceptTimeout = null;
        }
        
        if (this.dataChannel) {
            try { this.dataChannel.close(); } catch(e) {}
            this.dataChannel = null;
        }
        if (this.peerConnection) {
            try { this.peerConnection.close(); } catch(e) {}
            this.peerConnection = null;
        }
        
        this.selectedFile = null;
        this.selectedRecipient = null;
        this.receivedChunks = [];
        this.receivedSize = 0;
        this.fileMetadata = null;
        this.isReceiving = false;
        this.isTransferActive = false;
        this.waitingForAccept = false;
        this.transferComplete = false;
        this.incomingRequest = null;
    }
    
    cleanup() {
        // Only send cancel signal if transfer was NOT completed successfully
        if (this.selectedRecipient && !this.transferComplete && (this.isTransferActive || this.waitingForAccept || this.isReceiving)) {
            this.sendSignal(this.selectedRecipient.id, 'transfer-cancelled', { reason: 'Transfer cancelled by user' });
        }
        this.cleanupTransfer();
    }
    
    destroy() {
        window.removeEventListener('beforeunload', this.boundBeforeUnload);
        this.stopSignalPolling();
        this.cleanup();
    }
}

// Global P2P instance
let p2pShare = null;

// Context-aware defaults
const isPrivateP2PChat = '{{ chat.chat_type }}' === 'private';
const defaultP2PRecipient = {% if chat.chat_type == 'private' and other_participants %}{
    id: {{ other_participants.0.id }},
    name: "{{ other_participants.0.full_name|escapejs }}",
    is_online: {{ other_participants.0.is_online|yesno:'true,false' }}
}{% else %}null{% endif %};

// Initialize P2P on page load
document.addEventListener('DOMContentLoaded', function() {
    p2pShare = new P2PFileShare();
    p2pShare.isPrivateChat = isPrivateP2PChat;
    p2pShare.defaultRecipient = defaultP2PRecipient;
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (p2pShare) {
        p2pShare.destroy();
    }
});

// P2P UI Functions
function openP2PFileShare() {
    document.getElementById('p2pFileShareModal').style.display = 'flex';
    document.body.style.overflow = 'hidden';
    resetP2PModal();
    lucide.createIcons();
}

function closeP2PFileShare() {
    document.getElementById('p2pFileShareModal').style.display = 'none';
    document.body.style.overflow = '';
    if (p2pShare) {
        // Clear recipient refresh interval
        if (p2pShare.recipientRefreshInterval) {
            clearInterval(p2pShare.recipientRefreshInterval);
            p2pShare.recipientRefreshInterval = null;
        }
        p2pShare.cleanup();
    }
    resetP2PModal();
}

function closeP2PModal(event) {
    if (event.target.id === 'p2pFileShareModal') {
        closeP2PFileShare();
    }
}

function resetP2PModal() {
    if (p2pShare) {
        p2pShare.currentStep = 1;
        p2pShare.selectedFile = null;
        p2pShare.selectedRecipient = null;
        p2pShare.recipientAutoChosen = false;
    }
    
    document.getElementById('p2pStep1').style.display = 'block';
    document.getElementById('p2pStep2').style.display = 'none';
    document.getElementById('p2pStep3').style.display = 'none';
    document.getElementById('p2pSelectedFile').style.display = 'none';
    document.getElementById('p2pFileInput').value = '';
    document.getElementById('p2pNextBtn').disabled = true;
    document.getElementById('p2pNextBtnText').textContent = 'Select File';
    document.getElementById('p2pProgressFill').style.width = '0%';
}

function handleP2PFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (p2pShare) {
        p2pShare.selectedFile = file;
    }
    
    document.getElementById('p2pFileName').textContent = file.name;
    document.getElementById('p2pFileSize').textContent = p2pShare.formatFileSize(file.size);
    document.getElementById('p2pSelectedFile').style.display = 'flex';
    document.getElementById('p2pNextBtn').disabled = false;
    document.getElementById('p2pNextBtnText').textContent = 'Next';
    lucide.createIcons();
}

function clearP2PFile() {
    if (p2pShare) {
        p2pShare.selectedFile = null;
    }
    document.getElementById('p2pFileInput').value = '';
    document.getElementById('p2pSelectedFile').style.display = 'none';
    document.getElementById('p2pNextBtn').disabled = true;
    document.getElementById('p2pNextBtnText').textContent = 'Select File';
}

async function p2pNextStep() {
    if (!p2pShare) return;
    
    if (p2pShare.currentStep === 1) {
        // Private chat: auto-select the other participant and skip recipient step
        if (p2pShare.isPrivateChat && p2pShare.defaultRecipient) {
            p2pShare.selectedRecipient = { id: p2pShare.defaultRecipient.id, name: p2pShare.defaultRecipient.name };
            p2pShare.recipientAutoChosen = true;
            // If the default recipient is offline, block progression
            if (!p2pShare.defaultRecipient.is_online) {
                showToast('The other participant is offline. Please wait until they are online to send a file.', 'warning');
                return;
            }
            // Jump directly to transfer step
            p2pShare.currentStep = 3;
            p2pShare.waitingForAccept = true;
            document.getElementById('p2pStep1').style.display = 'none';
            document.getElementById('p2pStep2').style.display = 'none';
            document.getElementById('p2pStep3').style.display = 'block';
            document.getElementById('p2pNextBtn').style.display = 'none';
            
            document.getElementById('p2pTransferFileName').textContent = p2pShare.selectedFile.name;
            document.getElementById('p2pTransferFileSize').textContent = p2pShare.formatFileSize(p2pShare.selectedFile.size);
            
            await p2pShare.sendSignal(p2pShare.selectedRecipient.id, 'file-request', {
                file_name: p2pShare.selectedFile.name,
                file_size: p2pShare.selectedFile.size,
                file_type: p2pShare.selectedFile.type,
                sender_avatar: '{{ user.profile_picture_url }}'
            });
            
            p2pShare.updateTransferStatus('connecting', 'Waiting for acceptance...', 'Recipient has 60 seconds to accept');
            
            p2pShare.acceptTimeout = setTimeout(() => {
                if (p2pShare.waitingForAccept) {
                    p2pShare.updateTransferStatus('error', 'Request Timed Out', 'Recipient did not respond in time');
                    showToast('File request timed out', 'error');
                    setTimeout(() => closeP2PFileShare(), 3000);
                }
            }, p2pShare.ACCEPT_TIMEOUT);
            return;
        }

        // Group chats: proceed to recipient selection
        p2pShare.currentStep = 2;
        document.getElementById('p2pStep1').style.display = 'none';
        document.getElementById('p2pStep2').style.display = 'block';
        document.getElementById('p2pNextBtn').disabled = true;
        document.getElementById('p2pNextBtnText').textContent = 'Send File';
        lucide.createIcons();
        
        await loadP2PRecipients();
        
        // Start auto-refresh for recipient list every 3 seconds
        if (p2pShare.recipientRefreshInterval) {
            clearInterval(p2pShare.recipientRefreshInterval);
        }
        p2pShare.recipientRefreshInterval = setInterval(async () => {
            if (p2pShare && p2pShare.currentStep === 2) {
                await refreshP2PRecipientStatus();
            }
        }, 3000);
        
    } else if (p2pShare.currentStep === 2) {
        // Stop recipient refresh when moving to step 3
        if (p2pShare.recipientRefreshInterval) {
            clearInterval(p2pShare.recipientRefreshInterval);
            p2pShare.recipientRefreshInterval = null;
        }
        
        // Start transfer
        p2pShare.currentStep = 3;
        p2pShare.waitingForAccept = true;
        document.getElementById('p2pStep2').style.display = 'none';
        document.getElementById('p2pStep3').style.display = 'block';
        document.getElementById('p2pNextBtn').style.display = 'none';
        
        // Update transfer details
        document.getElementById('p2pTransferFileName').textContent = p2pShare.selectedFile.name;
        document.getElementById('p2pTransferFileSize').textContent = p2pShare.formatFileSize(p2pShare.selectedFile.size);
        
        // Send file request to recipient
        await p2pShare.sendSignal(p2pShare.selectedRecipient.id, 'file-request', {
            file_name: p2pShare.selectedFile.name,
            file_size: p2pShare.selectedFile.size,
            file_type: p2pShare.selectedFile.type,
            sender_avatar: '{{ user.profile_picture_url }}'
        });
        
        p2pShare.updateTransferStatus('connecting', 'Waiting for acceptance...', 'Recipient has 60 seconds to accept');
        
        // Set timeout for acceptance
        p2pShare.acceptTimeout = setTimeout(() => {
            if (p2pShare.waitingForAccept) {
                p2pShare.updateTransferStatus('error', 'Request Timed Out', 'Recipient did not respond in time');
                showToast('File request timed out', 'error');
                setTimeout(() => closeP2PFileShare(), 3000);
            }
        }, p2pShare.ACCEPT_TIMEOUT);
    }
}

async function loadP2PRecipients() {
    const list = document.getElementById('p2pRecipientList');
    list.innerHTML = '<div class="loading-members"><i data-lucide="loader" class="spin"></i> Loading...</div>';
    
    try {
        // Add timestamp to prevent caching
        const response = await fetch(`/api/p2p/${p2pShare.chatId}/participants/?t=${Date.now()}`, {
            headers: { 
                'X-CSRFToken': getCookie('csrftoken'),
                'Cache-Control': 'no-cache'
            }
        });
        const data = await response.json();
        
        if (data.success) {
            if (data.participants.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #64748b;">No other participants in this chat</p>';
                return;
            }
            
            list.innerHTML = data.participants.map(p => `
                <div class="p2p-recipient-item ${p.is_online ? '' : 'offline'}" 
                     onclick="selectP2PRecipient(${p.id}, '${p.full_name.replace(/'/g, "\\'")}', ${p.is_online})"
                     data-user-id="${p.id}">
                    <img src="${p.profile_picture}" alt="${p.full_name}" class="p2p-recipient-avatar"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="p2p-recipient-avatar-fallback" style="display: none;">
                        ${p.full_name.split(' ').map(n => n[0]).join('').substring(0, 2)}
                    </div>
                    <div class="p2p-recipient-info">
                        <div class="p2p-recipient-name">${p.full_name}</div>
                        <div class="p2p-recipient-status">
                            ${p.is_online ? '<span class="online-dot"></span>Online' : 'Offline'}
                        </div>
                        ${!p.is_online ? '<div class="p2p-offline-warning">‚ö†Ô∏è User must be online to receive</div>' : ''}
                    </div>
                </div>
            `).join('');
            
            lucide.createIcons();
        }
    } catch (error) {
        console.error('Error loading recipients:', error);
        list.innerHTML = '<p style="text-align: center; color: #ef4444;">Failed to load recipients</p>';
    }
}

// Refresh recipient status without full reload (preserves selection)
async function refreshP2PRecipientStatus() {
    try {
        const response = await fetch(`/api/p2p/${p2pShare.chatId}/participants/?t=${Date.now()}`, {
            headers: { 
                'X-CSRFToken': getCookie('csrftoken'),
                'Cache-Control': 'no-cache'
            }
        });
        const data = await response.json();
        
        if (data.success) {
            data.participants.forEach(p => {
                const item = document.querySelector(`.p2p-recipient-item[data-user-id="${p.id}"]`);
                if (item) {
                    const wasOnline = !item.classList.contains('offline');
                    const isNowOnline = p.is_online;
                    
                    // Update status if changed
                    if (wasOnline !== isNowOnline) {
                        if (isNowOnline) {
                            item.classList.remove('offline');
                        } else {
                            item.classList.add('offline');
                        }
                        
                        // Update click handler
                        item.onclick = () => selectP2PRecipient(p.id, p.full_name, isNowOnline);
                        
                        // Update status text
                        const statusEl = item.querySelector('.p2p-recipient-status');
                        if (statusEl) {
                            statusEl.innerHTML = isNowOnline 
                                ? '<span class="online-dot"></span>Online' 
                                : 'Offline';
                        }
                        
                        // Update/remove warning
                        let warningEl = item.querySelector('.p2p-offline-warning');
                        if (!isNowOnline && !warningEl) {
                            const infoEl = item.querySelector('.p2p-recipient-info');
                            if (infoEl) {
                                infoEl.insertAdjacentHTML('beforeend', '<div class="p2p-offline-warning">‚ö†Ô∏è User must be online to receive</div>');
                            }
                        } else if (isNowOnline && warningEl) {
                            warningEl.remove();
                        }
                        
                        // If selected recipient went offline, show warning and disable button
                        if (p2pShare.selectedRecipient && p2pShare.selectedRecipient.id === p.id) {
                            if (!isNowOnline) {
                                showToast('Selected user went offline', 'warning');
                                document.getElementById('p2pNextBtn').disabled = true;
                                item.classList.remove('selected');
                                p2pShare.selectedRecipient = null;
                            }
                        }
                    }
                }
            });
            
            lucide.createIcons();
        }
    } catch (error) {
        console.error('Error refreshing recipient status:', error);
    }
}

function selectP2PRecipient(userId, fullName, isOnline) {
    if (!isOnline) {
        showToast('User must be online to receive files via P2P', 'error');
        return;
    }
    
    // Remove previous selection
    document.querySelectorAll('.p2p-recipient-item').forEach(el => el.classList.remove('selected'));
    
    // Select this one
    const item = document.querySelector(`.p2p-recipient-item[data-user-id="${userId}"]`);
    if (item) {
        item.classList.add('selected');
    }
    
    if (p2pShare) {
        p2pShare.selectedRecipient = { id: userId, name: fullName };
    }
    
    document.getElementById('p2pNextBtn').disabled = false;
}

function cancelP2PTransfer() {
    if (p2pShare) {
        p2pShare.cleanup();
    }
    closeP2PFileShare();
    showToast('File transfer cancelled', 'info');
}

// Incoming file handling
function acceptP2PFile() {
    if (!p2pShare || !p2pShare.incomingRequest) return;
    
    p2pShare.isReceiving = true;
    p2pShare.transferComplete = false;
    p2pShare.selectedRecipient = { id: p2pShare.incomingRequest.from_user_id };
    
    // Send acceptance
    p2pShare.sendSignal(p2pShare.incomingRequest.from_user_id, 'file-accept', {});
    
    document.getElementById('p2pIncomingModal').style.display = 'none';
    showToast('Preparing to receive file...', 'info');
}

function rejectP2PFile() {
    if (!p2pShare || !p2pShare.incomingRequest) return;
    
    p2pShare.sendSignal(p2pShare.incomingRequest.from_user_id, 'file-reject', {});
    
    document.getElementById('p2pIncomingModal').style.display = 'none';
    p2pShare.incomingRequest = null;
    showToast('File transfer declined', 'info');
}

// Called when recipient accepts
P2PFileShare.prototype.onFileAccepted = async function(signal) {
    // Clear the accept timeout
    if (this.acceptTimeout) {
        clearTimeout(this.acceptTimeout);
        this.acceptTimeout = null;
    }
    this.waitingForAccept = false;
    this.transferComplete = false;
    
    this.updateTransferStatus('connecting', 'Accepted!', 'Establishing peer-to-peer connection...');
    await this.initConnection(true);
};

P2PFileShare.prototype.onFileRejected = function(signal) {
    // Clear the accept timeout
    if (this.acceptTimeout) {
        clearTimeout(this.acceptTimeout);
        this.acceptTimeout = null;
    }
    this.waitingForAccept = false;
    
    this.updateTransferStatus('error', 'Declined', 'Recipient declined the file transfer');
    showToast('File transfer was declined', 'error');
    setTimeout(() => closeP2PFileShare(), 2000);
};

function cancelP2PReceive() {
    if (p2pShare) {
        p2pShare.cleanup();
    }
    document.getElementById('p2pReceivingModal').style.display = 'none';
    showToast('File receive cancelled', 'info');
}
</script>
{% endblock %}
<!-- Odnix Call configuration + script (added to ensure signaling for non-Instagram template) -->
<script>
    try {
        window.OdnixCallConfig = {
            chatId: {{ chat.id }},
            userId: {{ request.user.id }},
            wsScheme: (window.location.protocol === 'https:' ? 'wss' : 'ws'),
            host: window.location.host,
            iceServers: []
        };
        console.log('[CallJS] Config set successfully (chat_detail):', window.OdnixCallConfig);
    } catch (e) {
        console.error('[CallJS] Error setting config (chat_detail):', e);
        alert('Error configuring call system: ' + e.message);
    }
</script>
<script src="{% static 'js/call.js' %}?v={% now 'U' %}"
    onload="console.log('call.js loaded successfully on chat_detail'); if(!window.OdnixCall) console.error('ERROR: window.OdnixCall is undefined after script load. Check call.js for syntax errors.');"
    onerror="console.error('Failed to load call.js on chat_detail'); alert('Error loading call functionality. Check console.');"></script>